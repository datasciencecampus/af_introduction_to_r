---
title: "Intro to R - Session Five"
output:
  html_document: 
    theme: united
    highlight: tango
    toc: yes
    toc_float: yes
    number_sections: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
```{r, echo=FALSE}
htmltools::img(src = knitr::image_uri("./Images/LATree.PNG"),
               alt = 'logo', 
               style = 'position:absolute; top:0; right:0; padding:10px; width:200px;')
```


# Session Five.

## Learning Objectives
**The goals of this session are to:**

* Understand how to obtain summary statistics.
* Be able to use R functions to obtain descriptive statistics.
* Be able to aggregate data in a data frame.


## Exercise {.tabset .tabset-fade}
### **Question**

Before we begin, could you load the packages below,

- `readr`

- `janitor`

- `dplyr`

- `ggplot2`

Read in the school dataset and assign it to `school`

Clean the names of the `school` dataset using the janitor package.


### **Show Answer**

```{r message=FALSE, warning=FALSE}
# Loading libraries
library(readr)
library(janitor)
library(dplyr)
library(ggplot2)

# Reading in the data.
school <- read_csv("Data/schools_data.csv", 
                   na=c("", " ", "NULL"))

# Clean the names using janitor.
school <- clean_names(school)
```
## Summary Statistics.

Summary statistics summarize large amounts of data by describing key characteristics such as the average, median, mode etc.

We can use the `summary()` function which returns the,

- Minimum value
- 1st quartile 25% value
- Median 50% value
- Mean, the unweighted average
- 3rd quartile 75% value
- Maximum value
- NA's number of missing values.

We can also get these indepently.

Some R functions for computing descriptive statistics.

| Description        | R function |
| -----------        | -----------|
| Mean               | mean()     |
| Median             | median()   |
| Mode               | **???**    |
| Minimum            | min()      |
| Maximum            | maximum()  |
| Range              | range()    |
| Quartiles          | quartile   |
| Quantiles          | quantiles  |
| Standard Deviation | sd()       |
| Variance           | var()      |
| Summary            | summary()  |


### Mean

The mean is the unweighted average value.

We can calculate the mean by using the `mean()` function.

The code below is calculating the mean for the `total_number_of_pupils` column. 

```{r}

# Calculate the mean
mean(school$total_number_of_pupils) 

```

As we can see our result was `NA` which suggests that there are missing values in the data. As any operation applied to `NA` produces `NA`.

We can quickly check for missing values using the summary function below.


```{r}

summary(school$total_number_of_pupils)

```

We can see that we have got 275 missing values.

To be able to calculate our mean we need to remove them from the calculation. We can do this by adding an argument within the function: `na.rm = TRUE`.

**na.rm = TRUE** means remove missing values (na means missing values and rm is remove), this removes the missing values before calculating the mean, not removing the values from the dataset.

```{r}

# Calculate the mean
mean(school$total_number_of_pupils, na.rm=TRUE) 

```
### Median


The median is defined as the value below which are 50% of the observations. 

For data sets with an even number of observations, the median falls half-way between the two middle values.

We can calculate the median using the `median()` function.

The code below is calculating the median for the `total_number_of_pupils` column. 

```{r}

# Calculate the median
median(school$total_number_of_pupils, na.rm = TRUE)

```

### Mode

The mode summary statistic is simply the most frequent value in a set of data.

If you noticed on my table of summary statistics, you will have noticed there was no function for calculating the mode.

Base R does not provide a function for finding the mode.

We would have to use a package to calculate the mode or write our own function.

The function `mfv()`, for most frequent value, `[in modeest package]` can be used to find the statistical mode.

Throughout the course we have used functions that have already been made for us, we are going to look at the mode function and writting our own functions in the next session.

### Minimum, Maximum and Range{.tabset .tabset-fade}

#### Minimum

This is the lowest value in the data set.
We can calculate the minimum using the `min()` function.

```{r}

# Calculate the minimum value.
min(school$total_number_of_pupils, na.rm = TRUE)

```

There is a PRU - Pupil Referal Unit that has 0 pupils

#### Maximum
This is the highest value in the data set.
We can calculate the maximum using the `max()` function.
```{r}

# Calculate the maximum value.
max(school$total_number_of_pupils, na.rm = TRUE)

```
#### Range
This is the difference between the highest and lowest values.
We can calculate the range using the `range()` function.
```{r}

# Calculate the range
range(school$total_number_of_pupils, na.rm = TRUE)

```
### Quantiles and Quartiles{.tabset .tabset-fade}

#### Quantiles
Quantiles sub-divide the data set into one hundred equal pieces. For
example, the 10th percentile will have 10 per cent of the data below it,
whereas the 90th percentile will have 90 per cent of the data below it. The
median lies at the 50th percentile.

```{r}

quantile(school$total_number_of_pupils,
         probs = c(0, 0.2, 0.4, 0.6, 0.8, 1),
         na.rm = TRUE)

```


#### Quartiles
Quartiles are another way in which a data set can be sub-divided.
Quartiles are a type of quantile but instead of splitting the data into
one hundred equal parts it splits the set into four equal parts.

```{r}

quantile(school$total_number_of_pupils,
         probs = c(0.25, 0.5, 0.75),
         na.rm = TRUE)


```
### Standard Deviation and Variance{.tabset .tabset-fade}

#### Standard Deviation
The standard deviation measures the spread of the data about the mean value. It shows you how much your data is spread out around the mean or average.
We can calculate the standard deviation using the `sd()` function.

```{r}

sd(school$total_number_of_pupils, na.rm = TRUE)


```
#### Variance
Variance measures how spread the values of a variable are.
We can calculate the variance using the `var()` function.
```{r}

var(school$total_number_of_pupils, na.rm = TRUE)

```
## Aggregations (groupby/summarise){.tabset .tabset-fade}

We might want to work with our data using one or more variables. The `group_by()` function allows us to aggregate our data. It groups the observations which then allows us to summarise them.

The code below creates a new dataset called `school_group_phase_of_education` from the `school` dataset, and then ( `%>%` ) grouping by the `phase_of_education` variable and then ( `%>%` ) summarising by the mean_number_of_pupils.

```{r}
school_group_phase_of_education <- school %>% 
  group_by(phase_of_education) %>% 
  summarise("mean_number_of_pupils" = mean(total_number_of_pupils , na.rm = TRUE))

# Calling the object to display it.
school_group_phase_of_education

```

We can now visualise that information. (We will see how `ggplot2` works later, for now you can just run this code to create a bar chart)

```{r}

# This code generates a plot of the data.
ggplot(school_group_phase_of_education,
        aes(x = phase_of_education,
            y = mean_number_of_pupils))+
        geom_col(aes(fill=phase_of_education))

```

We can `group_by` multiple variables.

The code below is creating a new dataset called `school_group_phase_of_education_and deprivation_index` from the `school` dataset, and then ( `%>%` ) grouping by the `phase_of_education` variable and `deprivation_index` and then ( `%>%` ) summarising by the `mean_number_of_pupils`.


```{r}

school_group_phase_of_education_and_deprivation_index <- school %>% 
    group_by(phase_of_education, deprivation_index) %>% 
    summarise("mean_number_of_pupils" = mean(total_number_of_pupils, na.rm = TRUE))

# Calling the object to display it
school_group_phase_of_education_and_deprivation_index

```
There are a few `NA's` and `NaN's` in here, let's investigate. 

(`NA` stands for not available and `NaN` stands for not a number e.g. 0/0)

Lets have a look at the Primary schools with no recorded `deprivation index.`

The code below is creating a new dataset called `Primary_schools_with_no_deprivation_index`, from the school dataset, by filtering the `phase_of_education` on the conditions that its equal to primary school and is a missing value.

```{r message=FALSE, warning=FALSE}

Primary_schools_with_no_deprivation_index <- filter(school, 
                                                    phase_of_education == "Primary"
                                                    & is.na(deprivation_index))

head(Primary_schools_with_no_deprivation_index)
```

We can see that we have a lot of missing values in this set.

We can decide to drop the missing values.


The code below is creating a new dataset called `school_with_no_missing_values_for_deprivation_index`, from the `school_group_phase_of_education_and_deprivation_index` dataset, by filtering on the condition that is it a missing value. The `!` symbol indicates a NOT condition. 

```{r message=FALSE, warning=FALSE}

school_with_no_missing_values_for_deprivation_index <- filter(school_group_phase_of_education_and_deprivation_index, 
       !is.na(deprivation_index)==TRUE)

# Displaying the values of the data frame.
school_with_no_missing_values_for_deprivation_index
```

We can visualise this, again we will look at data visualisation in a later session, so don't worry about understanding the code at this point in time.

```{r message=FALSE, warning=FALSE}

ggplot(school_with_no_missing_values_for_deprivation_index, 
       aes(x = deprivation_index,
           y = mean_number_of_pupils)) +
      geom_point(aes(col = phase_of_education), size=10)

```


Obtaining frequncies of categoricals can be done with the `count()` function.

```{r message=FALSE, warning=FALSE}

# Grouping by then counting
phase_of_education_frequency <- school %>% 
  group_by(phase_of_education) %>% 
  count()

# Display the data frame values
phase_of_education_frequency
```

### **Question**

Lets now practise using the `group_by` function.

**Can you use the `group_by` function to group by local authority, show the median number of pupils and mean number of pupils.**

### **Show Answer**

```{r}

aggregate_results <- school %>% 
       group_by(local_authority) %>% 
       summarise("median_number_pupils" = median(total_number_of_pupils, na.rm = TRUE),                            "mean_number_of_pupils"= mean(total_number_of_pupils, na.rm = TRUE)) 
      
# Display results
aggregate_results

```