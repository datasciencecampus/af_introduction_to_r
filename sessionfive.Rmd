---
title: "Intro to R - Session Five"
output:
  html_document: 
    theme: united
    highlight: tango
    toc: yes
    toc_float: yes
    number_sections: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
```{r, echo=FALSE}
htmltools::img(src = knitr::image_uri("./Images/LATree.PNG"),
               alt = 'logo', 
               style = 'position:absolute; top:0; right:0; padding:10px; width:200px;')
```


# Session Five.

## Learning Objectives
**The goal of this session is to:**

* Understand to obtain summary statistics
* Be able to use R functions to obtain descriptive statistics
* Be able to aggregate data in a data frame.


## Exercise {.tabset .tabset-fade}
### **Question**

Before we begin, could you load the packages below,

- readr

- janitor

- dplyr

- ggplot2

Read in the school dataset and assign it to `school`

Clean the names of the `school` dataset using the janitor package.


### **Show Answer**

```{r message=FALSE, warning=FALSE}
#loading libraries

library(readr)
library(janitor)
library(dplyr)
library(ggplot2)

#Reading in the data

school <- read_csv("Data/schools_data.csv", 
                   na=c("", " ", "NULL"))


# clean the names using Janitor

school <- clean_names(school)


```
## Summary Statistics.

Summary statistics summarize large amounts of data by describing key characteristics such as the average, median, mode etc.

We can use the `summary()` function which returns the,

- minimum value
- 1st quartile 25% value
- median 50% value
- mean the avarage
- 3rd quartile 75% value
- Maximum value
- NA'S number of missing values.

We can also get these indepently.

Some R functions for computing descriptive statistics.

| Description        | R function |
| -----------        | -----------|
| Mean               | mean()     |
| Median             | median()   |
| Mode               | **???**    |
| Minimum            | min()      |
| Maximum            | maximum()  |
| Range              | range()    |
| quartiles          | quartile   |
| quantiles          | quantiles  |
| Standard Deviation | sd()       |
| Variance           | var()      |
| Summary            | summary()  |


### Mean

The mean is the average value.

We can calculate the mean by using the `mean()` function.

Loading libraries and data.



The code below is calculating the mean for the `total_number_of_pupils` column. 

```{r}

#Calculate the mean

mean(school$total_number_of_pupils) 

```

As we can see our result was `NA` which suggests that there are missing values in the data. As any operation applied to `NA` produces `NA`.

We can quickly check for missing values using the summary function below.


```{r}

summary(school$total_number_of_pupils)

```

We can see that we have got 275 missing values.

To be able to calculate our mean we need to remove them form the calculation and we can do this by adding an arguement `na.rm = TRUE`
**na.rm = TRUE**, stands for remove missing values(na stands for missing values and rm is remove), this removes them before calculating the mean and not from the dataset.

```{r}

#Calculate the mean

mean(school$total_number_of_pupils, na.rm=TRUE) 

```
### Median


The median is defined as the value below which are 50% of the observations. 

For data sets with an even number of observations, the median falls half-way between the two middle values.

We can calculate the median using the `median()` function.

The code below is calculating the median for the `total_number_of_pupils` column. 

```{r}

 median(school$total_number_of_pupils, na.rm = TRUE)

```

### Mode

The mode is a summary statistic that is used rarely in practice, this is simply the most frequent value.

If you noticed on my table of summary statistics, you will have noticed i had no function for calculating the mode.

Base R does not provide a function for finding the mode.

We would have to use a package to calculate the mode or write our own function.

The `function mfv()`, for most frequent value, `[in modeest package]` can be used to find the statistical mode.

Throughout the course we have used already set functions, we are going to look at mode function and writting our own functions in the next session.

### Minimum, Maximum and Range{.tabset .tabset-fade}

#### Minimum

This is the lowest value.
We can calculate the minimum using the `min()` function.

```{r}

min(school$total_number_of_pupils, na.rm = TRUE)

```

There is a PRU - Pupil Referal Unit that has 0 pupils

#### Maximum
This is the highest value.
We can calculate the maximum using the `max()` function.
```{r}

max(school$total_number_of_pupils, na.rm = TRUE)

```
#### Range
This is the difference between the highest and lowest values.
We can calculate the range using the `range()` function.
```{r}

range(school$total_number_of_pupils, na.rm = TRUE)

```
### Quantiles and Quartiles{.tabset .tabset-fade}

#### Quantiles
Quantiles sub-divide the data set into one hundred equal pieces. For
example, the 10th percentile will have 10 per cent of the data below it,
whereas the 90th percentile will have 90 per cent of the data below it. The
median lies at the 50th percentile.

```{r}

quantile(school$total_number_of_pupils,
         probs = c(0, 0.2, 0.4, 0.6, 0.8, 1),
         na.rm = TRUE)

```


#### Quartiles
Quartiles are another way in which a data set can be sub-divided.
Quartiles are a type of quantile but instead of splitting the data into
one hundred equal parts it splits it into four equal parts.

```{r}

quantile(school$total_number_of_pupils,
         probs = c(0.25, 0.5, 0.75),  # More than one c()
         na.rm = TRUE)


```
### Standard Deviation and Variance{.tabset .tabset-fade}

#### Standard Deviation
The standard deviation measures the spread of the data about the mean value. It shows you how much your data is spread out around the mean or average.
We can calculate the standard deviation using the `sd()` function.

```{r}

sd(school$total_number_of_pupils, na.rm = T)


```
#### Variance
Variance measures how far a data set is spread out.
We can calculate the variance using the `var()` function.
```{r}

var(school$total_number_of_pupils, na.rm = T)

```
## Agreggations(groupby/summarise){.tabset .tabset-fade}

We might want to work with our data by one or more variables. The `group_by()` function allows us to 
aggregate our data.It groups the observations and then summarises them.

The code below is creating a new dataset called `school_group_phase_of_education` from the `school` dataset, and then ( %>% ) grouping by the `phase_of_education` variable and then ( %>% ) summarising by the mean_number_of_pupils

```{r}
school_group_phase_of_education <- school %>% 
  group_by(phase_of_education) %>% 
  summarise("mean_number_of_pupils" = mean(total_number_of_pupils , na.rm = T))

school_group_phase_of_education

```

Visualise that.(We will see how ggplot2 works later, for now you can just run this code to create a bar chart)

```{r}

ggplot(school_group_phase_of_education,
       aes(x= phase_of_education,
           y= mean_number_of_pupils))+
  geom_col(aes(fill=phase_of_education))

```

We can `group_by` multiple variables.

The code below is creating a new dataset called `school_group_phase_of_education_and deprivation_index` from the `school` dataset, and then ( %>% ) grouping by the `phase_of_education` variable and `deprivation_index` and then ( %>% ) summarising by the mean_number_of_pupils


```{r}

school_group_phase_of_education_and_deprivation_index <- school %>% 
  group_by(phase_of_education, deprivation_index) %>% 
  summarise("mean_number_of_pupils" = mean( total_number_of_pupils , na.rm = T))

school_group_phase_of_education_and_deprivation_index

```
There are a few `NA's` and `NaN's` in here, let's investigate. 
(`NA` stands for not available and `NAN` stands for not a number e.g. 0/0)

lets have a look at the Primary schools with schools with no recorded `deprivation index.`

The code below is creating a new dataset called `Primary_schools_with_no_deprivation_index`, from the school dataset, by filtering the `phase_of_education` on the conditions that its equal to primary school and is a missing value.

```{r message=FALSE, warning=FALSE}

Primary_schools_with_no_deprivation_index <- filter(school, phase_of_education == "Primary"
            & is.na(deprivation_index))



head(Primary_schools_with_no_deprivation_index)
```

We can see that we have a lot of missing values.

We can decide to drop the missing values.


The code below is creating a new dataset called `school_with_no_missing_values_for_deprivation_index`, from the school_group_phase_of_education_and_deprivation_index` dataset, by filtering on the condition that is it a missing value.

```{r message=FALSE, warning=FALSE}

school_with_no_missing_values_for_deprivation_index <- filter(school_group_phase_of_education_and_deprivation_index, !is.na(deprivation_index)==TRUE)


school_with_no_missing_values_for_deprivation_index
```

We can visualise this, again we will look at data visualisation in a later session, so dont worry about understanding the code at this point in time.

```{r message=FALSE, warning=FALSE}

ggplot(school_with_no_missing_values_for_deprivation_index, aes(x = deprivation_index, y = mean_number_of_pupils)) +
  geom_point(aes(col = phase_of_education), size=10)

```


Obtaining frequencies of Obtaining frequncies of categoricals can be done with `count()` function.

```{r message=FALSE, warning=FALSE}


phase_of_education_frequency <- school %>% 
  group_by(phase_of_education) %>% 
  count()

phase_of_education_frequency
```

### **Question**

Lets now practise using the `group_by`.

**Can you use the `group_by` function to group by local authority, and show the median number of pupils and mean number of pupils.**

### **Show Answer**

```{r}

aggregate_results <- school %>% 
       group_by(local_authority) %>% 
       summarise("median_number_pupils" = median(total_number_of_pupils,na.rm = T ), "mean_number_of_pupils"= mean(total_number_of_pupils, na.rm = T)) 
      

aggregate_results

```