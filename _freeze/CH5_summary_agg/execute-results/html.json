{
  "hash": "901519ab0ed5215d206a9f25ce31df6b",
  "result": {
    "markdown": "---\ntitle: \"Chapter 5: Summaries and Aggregation\"\nauthor: \"Government Analysis Function and ONS Data Science Campus\"\nengine: knitr\nexecute:\n  echo: true\n  eval: false\n  freeze: auto  # re-render only when source changes\n---\n\n\n> To switch between light and dark modes, use the toggle in the top left\n\n# Learning Objectives\n\n* Describe numeric and categorical data using statistics such as:\n    * Mean\n    * Median\n    * Standard Deviation\n    * Variance\n\n* Aggregate data\n\n\n# Packages and Data \n\nWe will use the titanic dataset and clean its column names with janitor.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load in packages\n\nlibrary(tidyverse)\nlibrary(janitor)\n\n# Prepare the dataset\n\ntitanic_data <- read_csv(\"Data/titanic.csv\", \n                           na = c(\"*\", \".\", \"\", \"NULL\"))\n\ntitanic_data <- clean_names(titanic_data)\n\nglimpse(titanic_data)\n```\n:::\n\n\n\n# Descriptive Statistics\n\nThere are two broad types of data in our tibble:\n\n* Numerical data (i.e. ints and doubles) \n* Text data (i.e. character strings)\n\n\n## Numerical Data\n\nThe **summarise()** verb allows us to create one or more numeric variables summarising the variables we specify. \n\nThere are many summary statistics functions we can use with summarise(): \n\n* **mean()** - The average (arithmetic mean) data value in the given column.\n* **median()** - The middle value of an ordered vector of values.\n    * If the vector has an odd number of values, it is the exact middle value.\n    * If the vector has an even number of values, there is no middle, so the median is the average of the numbers either side (e.g. if there are 80 values, the median is the average of the 39th and 40th value).\n* **var()** - The variance measures the degree of spread of each point from the mean. It is the square of the standard deviation.\n* **sd()** - The standard deviation (spread) of values in from the mean. It is the square root of the variance. \n* **quantile()** - Produces sample quantiles corresponding to the given proportions (between 0 and 1). We can compute upper and lower quartiles with this.\n* **min()** - The smallest value in the given column.\n* **max()** - The maximum value in the given column.\n* **n()** - Counts the number of entries (rows).\n* **n_distinct()** - Counts the number of unique entries for a given variable.\n\n\n### **Examples**{-}\n\nLet's compute the mean fare paid by passengers on the titanic. \n\nThe **summarise()** verb takes the following form:\n\n> **summarise(agg_col_name = summary_function(col))** notice that we can name the column as well!\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Calculating the mean fare paid \n\ntitanic_data |> \n    summarise(mean(fare)) # Compute mean of fare column\n```\n:::\n\n\n>**This highlights something very important, that any operation applied to a column containing one or more missing values, produces an average of NA.** \n\nThis is because we are adding something that is Not a Number (it does not exist) to an actual number, which is not defined (think dividing by 0 or adding infinity).\n\nBy default, this will throw most of the summary functions, but there is an optional parameter we can turn on, called \"**na.rm = TRUE**\".\n\nThis will omit any NA values in our calculation and produce a more meaningful result, albeit on a subset of observed data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Calculating the mean fare paid by passengers, removing NAs\n\ntitanic_data |>  \n    summarise(mean(fare, na.rm = TRUE))\n```\n:::\n\n\nTo assign this a meaningful column name, we'd pass a keyword argument before the summary function used:\n\n>**agg_col_name = summary_function(column, na.rm = TRUE)**\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Calculating the mean fare paid and naming it\n\ntitanic_data |> \n    summarise(mean_fare = mean(fare, na.rm = TRUE))\n```\n:::\n\n\n\nIf we didn't care about the tibble output summarise generates, we could simply compute using base R syntax:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Calculating the mean fare with base R\n\nmean(titanic_data$fare, na.rm = TRUE)\n```\n:::\n\n\nLike we saw with mutate() and other functions, we can compute multiple statistics through **summarise()**, separating with commas.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Calculating multiple summary statistics with summarise()\n\ntitanic_data |>  \n    summarise(median_fare = median(fare, na.rm = TRUE),\n              mean_fare = mean(fare, na.rm = TRUE),\n              sd_fare = sd(fare, na.rm = TRUE),\n              median_age = median(age_of_passenger, na.rm = TRUE),    \n              mean_age = mean(age_of_passenger, na.rm = TRUE),        \n              sd_age = sd(age_of_passenger, na.rm = TRUE))\n```\n:::\n\n\n### Quantiles\n\nWe can also calculate quantiles, such as the upper and lower quartile within summarise(). \n\nTo do this, we must specify a value between 0 and 1, which denotes the nth percentile/quantile. For example:\n\n* 0.1 denotes the 10th percentile - All values in order up to the value at the 10% spot.\n* 0.25 denotes the lower quartile - All values in order up to the value at the 25% spot.\n* 0.75 denotes the upper quartile - All values in order up to the value at the 75% spot.\n\n### **Examples**{-}\n\nThe quantile function is structured as:\n\n> **quantile(col, probs = c(0,1),..)** where probs should be the value of the quantile you want.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Computing the lower quartile\n\ntitanic_data |> \n    summarise(fare_lower = quantile(fare, probs = 0.25, na.rm = TRUE))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Computing the upper quartile\n\ntitanic_data |> \n    summarise(fare_upper = quantile(fare, probs = 0.75, na.rm = TRUE))\n```\n:::\n\n\n\n## Categorical Data \n\nSimple statistics on qualitative data include:\n\n* **distinct()** - Displays the unique values in a given column. \n\n* **count()** - Displays the number of occurrences of each unique entry in a given column.\n\nThese (of course) will not work well on columns that are almost entirely unique, such as the name of passenger!\n\n\n### **Examples**{-}\n\nLet's start with **count()**, which we can sort with the extra parameter **sort = TRUE** for a descending order output. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Calculating frequency of each unique passenger name\n\ntitanic_data |> \n    count(name_of_passenger, sort = TRUE)\n```\n:::\n\n\nCompared this to a categorical variable with only a few unique categories, like embarked. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Calculating the number of passengers embarked from each port\n\ntitanic_data |> \n    count(embarked, sort = TRUE)\n```\n:::\n\n\nLet's see distinct() in action:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Select only unique/distinct rows from the embarked column\n \ntitanic_data |> \n    distinct(embarked)\n```\n:::\n\n\n\n## Exercise\n::: {.panel-tabset}\n\n### **Exercise**{-}\n\n1. Use summarise() to return the ages of the oldest and youngest passengers on the titanic.\n\n2. Use a summary function for categorical data to determine the number of men and women in the dataset.\n\n### **Show Answer**{-}\n\n1. \n\n::: {.cell}\n\n```{.r .cell-code}\n# Calculating the oldest and youngest\n\ntitanic_data |> \n    summarise(youngest_age = min(age_of_passenger, na.rm = TRUE),\n              oldest_age = max(age_of_passenger, na.rm = TRUE))\n```\n:::\n\n\n2. \n\n::: {.cell}\n\n```{.r .cell-code}\n# Calculating the count of men and women on the titanic\n\ntitanic_data |> \n    count(sex_of_passenger)\n```\n:::\n\n\nWe see that there were almost twice as many men as there were women on the titanic. \n\n:::\n\n# Aggregation\n\nAggregation means grouping data together by a particular grouping variable and producing a summary of one or more columns for that grouping variable.\n\nFor example, we might want to see the average fare paid **by** sex or **by** port embarked from. \n\nThe **group_by()** function from dplyr is the bread and butter of this section.\n\n## Group By\n\nGroup by performs the aggregation necessary so that we can use summarise() from before to obtain numeric summaries by group. \n\nIt is formed on a principle known as **split - summarise - combine**\n\n* Split - The tibble is divided into a set of smaller tibbles, based on the grouping variable.\n    For example, if we use a variable with 3 unique categories, 3 smaller tibbles are created.\n\n* Summarise - An aggregate statistic is applied to each of the groups (such as the mean of their fare paid) and a single row for each group is output.\n\n* Combine - The individual outputs from aggregation are combined into a new tibble.\n\n\n### Example\n\nLet's look at this in code by finding the mean fare for each passenger class.\n\nThe sequence of code will go as follows:\n\n> **group_by(col) |> summarise(agg_col = summary_function(col))**\n\nFirstly, let's check how many classes there are:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# How many pclasses are there?\n\ntitanic_data |>\n    distinct(pclass)\n```\n:::\n\n\nSo we should expect three values, one mean fare for each of the passenger classes. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Calculate mean fare by passenger class\n\ntitanic_data |> \n    group_by(pclass) |> \n    summarise(mean_fare = mean(fare, na.rm = TRUE))\n```\n:::\n\n\n### The similarity of count() and group_by()\n\nAn interesting point to make is that we can use the n() summary statistic to count the number of observations in that group after a group_by.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Group by and count the number of unique groups\n\ntitanic_data |> \n    group_by(pclass) |> \n    summarise(n = n())\n```\n:::\n\n\nThis looks similar to the output of another function we used!\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Replicate the above result with a different function\n\ntitanic_data |> \n    count(pclass)\n```\n:::\n\n\nit is the case the count() is performing the exact same computations in the background as the combination of group_by() and summarise()! \n\nA great shortcut if a count is all you need. \n\n## Multiple Aggregation\n\nWe can also double aggregate with more complex groupings. For example, we may require the mean fare paid by first class passengers leaving from Southhampton.\n\nWe would need to group by both passenger class and embarked to achieve this. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Group by pclass and embarked and find mean fare\n\ntitanic_data |> \n    group_by(pclass, embarked) |> \n    summarise(mean_fare = mean(fare, na.rm = TRUE))\n```\n:::\n\n\nWe see that since there are 3 passenger classes and 4 (with the null value) embarked entries, there are 3 * 4 = 12 possible combinations, with 10 outputting here (there are no second or third class null values).\n\nOrder does not matter here as it just determines what the final groupings look like, we will still get the same 12 each time.\n\nThe output itself will of course differ as it displays the groups in the order we grouped them:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Group by embarked and pclass and find mean fare\n\ntitanic_data |> \n    group_by(embarked, pclass) |> \n    summarise(mean_fare = mean(fare, na.rm = TRUE))\n```\n:::\n\n\n### Exercise\n::: {.panel-tabset}\n\n### **Exercise**{-}\n\n1. What is the average fare paid by men and women?\n\n\n2. What is the median fare paid by men and women in each passenger class?\n\n\n### **Show Answer**{-}\n\n1. \n\n::: {.cell}\n\n```{.r .cell-code}\n# Calculating the average fare by sex\n\ntitanic_data |> \n    group_by(sex_of_passenger) |> \n    summarise(mean_fare = mean(fare,\n                               na.rm = TRUE))\n```\n:::\n\n\n2. \n\n::: {.cell}\n\n```{.r .cell-code}\n# Calculating the median fare by sex and passenger class\n\ntitanic_data |> \n    group_by(sex_of_passenger, pclass) |> \n    summarise(median_fare = median(fare,\n                                   na.rm = TRUE))\n```\n:::\n\n:::\n\n\n## The impact of NAs\n\nIdeally, we don't want the null values being a category of their own and cluttering up our summary tables.\n\nWhen investigating data, we either:\n\n* Deal with these at read in.\n* Meticulously clean them with imputation methods (fill them in).\n* Drop them entirely (be very careful with this!).\n\n**tidyr** comes to the rescue when we are dealing with NAs as it has some handy functions to work with them:\n\n* drop_na() removes all rows with missing values present.\n* replace_na() fills in the missing values with whatever we specify. \n\nLet's see a few small examples of this in practice.\n\n### Filling missing values\n\nWe should always attempt to understand why values are missing before dealing with them. \n\nDomain expertise comes into play when deciding whether it makes sense for a value to be missing, think of temperature:\n\n> **A missing temperature reading is not the same as a temperature reading of 0 degrees celsius.**\n    \nAs such, it wouldn't make sense to fill the NAs with 0, as we create **bias** by over inflating the number of 0 temperature values.\n\nA better approach in cases such as this is to fill with an **average**, preferably one not impacted by outliers, such as the median.\n\n### **Example**{-}\n\nLet's consider first which numeric variables have missing values. We can check this by using the **is.na()** function.\n\nThis returns a vector of TRUEs and FALSEs, one for each cell in the table, for whether they are missing or not. \n\nWe can then sum() these up to find the total number of missing values in that column. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Compute number of missing values in age_of_passenger\n\ntitanic_data$age_of_passenger |> \n    is.na() |> \n    sum()\n```\n:::\n\n\nRepeating this for each column becomes laborious quickly, so there are some options for us:\n\n* Use **colSums()** to sum the outputs of a function across columns.\n* Create a **User defined function** or **Anonymous Function** to apply across the columns of the dataset using functional programming in purrr.\n\nWhilst the latter is recommended, it is beyond the scope of this current chapter, and features in later more advanced courses. \n\nLet's try colSums():\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Use colSums() to find the missing values\n\ntitanic_data |> is.na() |> \n    colSums()\n```\n:::\n\n\nNow that we have understood the number of missing values, let's see some imputation.\n\n### **Filling a numeric column with an average**{-}\n\nWe know that age_of_passenger has 267 missing values, but filling these in with 0 makes no sense and will skew the data.\n\nA better approach would be to impute with an average, that way we maximise our attempt to keep the data centralised. \n\nHowever, we must also be careful which statistic we use, as some are more robust than others:\n\n* The mean is heavily influenced by outliers (as it includes them in the calculation).\n* The median is a more robust measure as it does not consider the end points of the data (not influenced by outliers).\n    \n#### **Example**{-}\n\nThe replace_na() functions takes a few arguments:\n\n* The data itself\n* replace - What to fill the NAs with\n\nUsing this effectively requires us to also use **mutate()** as this modifies an existing column, as opposed to us using base R functionality to refer to columns with **$**.\n\nLet's use is.na() and colSums() to check it worked:\n    \n\n::: {.cell}\n\n```{.r .cell-code}\n# Impute missing age values with median \n\ntitanic_data <- titanic_data |> # overwrite to save changes\n    mutate(age_of_passenger = replace_na(age_of_passenger,\n                                         replace = median(age_of_passenger,\n                                                          na.rm = TRUE)))\n```\n:::\n\n\nLet's check this worked:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Check imputation\n\ntitanic_data |> is.na() |> \n    colSums()\n```\n:::\n\n\n\n### **Filling a categorical column with an average**{-}\n\nWith categorical columns, the most robust method we can use to impute is using the most frequently occuring value, or the **mode**. \n\nThere is no built in function for this in base R, requiring an outside package in order to so. However, we can observe the mode with the output from count().\n\n#### **Example**{-}\n\nWe saw that embarked had 2 missing values, let's fill them with the mode.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Find the mode of the embarked column\n\ntitanic_data |> \n    count(embarked)\n```\n:::\n\n\nWe see that \"S\" or \"Southhampton\" was the most commonly departed from port among passengers.\n\nLet's fill this in with replace_na():\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Fill embarked in with the mode\n\ntitanic_data <- titanic_data |> \n    mutate(embarked = replace_na(embarked, replace = \"S\")) \n```\n:::\n\n\nLet's check again:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Check that embarked impute worked\n\ntitanic_data |> is.na() |> \n    colSums()\n```\n:::\n\n\nImputation is a very deep topic and goes beyond the scope of the course, but we recommend researching this for other examples.\n\n\n### Dropping Missing Values\n\nWe must be very careful about doing this, as we previously noted that there may be a pattern to how or why they are missing, and as such can be treated.\n\nWe risk lowering variance across our dataset by removing them, but if analysis determines that there is no easy way to impute them, dropping them might be the only option.\n\n### **Example**{-}\n\nWe use the drop_na() function to drop null values remaining. \n\n* In our example, cabin is roughly 75% missing, and with a variety of categories of all different forms, imputation would be a nightmare. \n    * As such, we would elect to exclude this column with **select()**.\n\n* Similarly, there is only one missing fare value, which it is more efficient to drop than fill with an average.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Drop the null values in fare\n\ntitanic_data <- titanic_data |> \n    select(-cabin) |> \n    drop_na(fare)\n```\n:::\n\n\n\n\n# Summary \n\nWell done for working your way through this whistle stop tour of aggregation and summary statistics!\n\nThis is the final compulsory chapter of the course, and as such your next steps are up to you, some recommendations we would make are:\n\n* Complete the additional chapter, chapter 6, which is a case study that tests the skills you've learnt in this course on a new dataset. \n\n* Complete the Additional Chapter, chapter 7, that covers more advanced concepts, such as:\n    * Pivoting data\n    * Binning numeric columns to categorical columns.\n    * Functional programming tools with purrr.\n    * Extra list functionality.\n\n* Complete any of the R courses that this course is a pre-requisite for on the [Learning Hub](https://learninghub.ons.gov.uk/local/catalogue/index.php), such as:\n    * [Data Visualization in R](https://learninghub.ons.gov.uk/course/view.php?id=553)\n    * [Statistics in R](https://learninghub.ons.gov.uk/course/view.php?id=560)\n    * [Modular Programming in Python and R](https://learninghub.ons.gov.uk/course/view.php?id=574)",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}