{
  "hash": "b1ce5c50aa850e7934a0d4fed9380a75",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Chapter 2 - Data Structures in R\"\nauthor: \"Government Analysis Function and ONS Data Science Campus\"\nengine: knitr\nexecute:\n  echo: true\n  eval: true\n  freeze: auto  # re-render only when source changes\n---\n\n\n\n\n> To switch between light and dark modes, use the toggle in the top left\n\n# Learning Objectives\n\n* Be familiar with data structures in R.\n* Understand how vectors operate.\n* Be familiar with lists.\n* Be familiar with data frames and tibbles.\n\n\n# Data Structures\n\nWe rarely work with single data values, we often work with a combination or collection of data.\n\nR organises these in certain structures, and stores this data so that we can manipulate and work with it.\n\n# Vectors\n\nIn the previous chapter we looked at variables, where we said we could assign a name to a value. \n\nCrucially, each of these values (and by extension the variable itself) has an associated datatype.\n\nIn the below example, we create a variable with the **character** data type.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# To assign a variable\n\nmy_friends <- \"ian\"\n```\n:::\n\n\n\n\nSuppose you wanted to store more than one value in \"my_friends\", e.g \"hannah\", \"mike\", \"almas\".\n\nThe following seem like possible solutions to this problem, but unfortunately are not the correct way to store multiple data points.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# This code will throw an error\n\nmy_friends <- \"ian\", \"hannah\", \"mike\", \"almas\"\n\nmy_friends <- (\"ian\", \"hannah\", \"mike\", \"almas\")\n```\n:::\n\n\n\n\nYou will get the error below,\n\n>**Error: unexpected ',' in \"my_friends <- \"ian\",\"**\n\nas the comma should not be used in this way.\n\nThis brings us to the **c()** function.\n\n\n## The c() Function\n\nThe \"c()\" function is used for creating a vector in R, which is it's most simple data structure. The c stands for **combine**.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#To access the R help documentation\n\n?c()\n\n# or\n\nhelp(c)\n```\n:::\n\n\n\n\nWe can use this function to store multiple elements (data points) in a single variable, with each element **separated by a comma**.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Creating a vector\n\nmy_friends <- c(\"ian\", \"hannah\", \"mike\", \"almas\")\n\n# To display the data\n\nmy_friends\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"ian\"    \"hannah\" \"mike\"   \"almas\" \n```\n\n\n:::\n:::\n\n\n\n\nLet's check the datatype of our new vector.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Check datatype of my_friends\n\ntypeof(my_friends)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n:::\n\n\n\n\nWe see that this is a character vector, a.k.a, a vector containing character data. This is because each element contained within the vector are character type. \n\n\n## Vector Definition\n\nA vector is a collection of values that are **all of the same type** (doubles, characters, etc.).\n\nSince R insists all elements in a vector have to be of the same type we then can have types of vectors. These are:\n\n* Logical vector - contains only logical values.\n* Numerical vector - contains only numerical values.\n* Character vector - contains only character values. \n\nThere are more types of vectors, but for the purpose of our learning these  are sufficient.\n\nVisually:\n\n![](Images/vector.png){fig-alt=\"Diagram of a vector as a column (collection) of the same red rectangle.\"}\n\n## Creating Vectors \n\nThere are several different ways of creating a vector. You can create a vector by using:\n\n- The combine function **c()** that we saw previously.\n\n- The sequence function **seq()** to create any sequence of numbers.\n\n- The **colon** operator to create a vector of consecutive numbers.\n\n\n### The c() function (combine)\n\nLet's create a numeric vector with c() this time!\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Creating a vector using the combine function\n\nsample_vector <- c(1, 2, 3, 4, 5)\n\n# To display the created vector\n\nsample_vector  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3 4 5\n```\n\n\n:::\n:::\n\n\n\n\n### The seq() function (sequence)\n\nA sequence of values has:\n\n* A starting point\n* An ending point\n* A \"step\", a.k.a the value we jump by from number to number.\n\n> For example, if we start at 2, end at 10 and step by 2 we will have (2, 4, 6, 8, 10) as our final sequence. \n\nThe seq() function takes the arguments:\n\n* from - the start point\n* to - the end point\n* by - the step value\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Creating a vector using the sequence function,\n\nsequence_vector <- seq(from = 2, to = 6, by = 2)\n\n# To display the created vector\n\nsequence_vector\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2 4 6\n```\n\n\n:::\n:::\n\n\n\n\nEarlier we saw in the console the number [1] next to our output. This represents the position of the element to the right of this number in the vector. \n\nThus, 2 is element 1 of our vector, 4 is element 2 and so on. This is essential information for later.\n\n\n### The Colon Operator\n\nA range of values (i.e., consecutive values) could be generated as a vector using a colon **:** in R.\n\nSince this is consecutive, we can't have broken sequences like seq() allows.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Creating a vector using a colon\n\ncolon_vector <- 6:10\n\n# To display the created vector\n\ncolon_vector\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  6  7  8  9 10\n```\n\n\n:::\n:::\n\n\n\n\n\n### Exercise\n::: {.panel-tabset}\n\n### **Exercise** {-}\n\n1. Create two vectors, one with numeric data and one with character data and name them appropriately. For example favourite_movies, lucky_numbers.\n\n2. Use the c() function to create a new vector with your vectors as inputs. This combines the smaller vectors into a larger vector, further showcasing their versatility.\n\n3. Find the type of your new vector. Why do you think this is the case?\n\n### **Show Answer**{-}\n\n1. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Creating a character vector\n\nfavourite_movies <- c(\"Frozen\", \"The Lion King\", \"Moana\", \"The Dark Knight\") \n\n# To display the data\n\nfavourite_movies\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Frozen\"          \"The Lion King\"   \"Moana\"           \"The Dark Knight\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# Creating a numeric vector \n  \nlucky_numbers <- c(7, 12, 15, 1)  \n\n# To display the data\n\nlucky_numbers\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  7 12 15  1\n```\n\n\n:::\n:::\n\n\n\n\n2. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Creating a vector of vectors\n\nmovies_and_numbers <- c(favourite_movies, lucky_numbers)\n\nmovies_and_numbers\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Frozen\"          \"The Lion King\"   \"Moana\"           \"The Dark Knight\"\n[5] \"7\"               \"12\"              \"15\"              \"1\"              \n```\n\n\n:::\n:::\n\n\n\n\n3. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Checking the type of vector\n\ntypeof(movies_and_numbers)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n:::\n\n\n\n\n:::\n\nWe end up with a character vector as opposed to an error for incompatible types (numeric and character). \n\nAs vectors are supposed to be of the same data type, R will convert values so that they are all the same datatype. This is called **coercion**, which works on a complex heirarchy:\n\n* Any datatype can be converted to a character by wrapping it in quotation marks **\" \"**. \n* Any integer can be converted to a double by adding in the decimal place, i.e. 1L --> 1.0\n* Any logical can be converted to an integer or double as they have numeric representation as 1 and 0 (or 1.0, 0.0) in the background.\n\nHowever, a character such as \"hello\" cannot be converted to any other type.\n\nAs such, we have:\n\n>**Logical < Integer < Double < Character** and we see that character is the most all encompassing, with logicals being converted from but not to. \n\n\n## Vectorised Language\n\nVectors aren't just containers for homogeneous data (data of the same type). \n\n> **As R is a vectorised language, this means operations are applied to each element of the vector automatically, without the need to loop through the vector.** \n\nThis is not a common behaviour among programming languages and is a key advantage of R's nature as a vectorised language.\n\nThis also means that every variable we have created so far have also been vectors with one element, and the operators (such as adding 5 to them) have been vectorised operations. \n\nLet's see this in practice!\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Add sample and colon vector\n\nvector_addition <- sample_vector + colon_vector\n\n\nvector_addition\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  7  9 11 13 15\n```\n\n\n:::\n:::\n\n\n\n\nWe see that each first element is added, each second element is added and so on, this is an element wise operation (element by element).\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Multiplying vectors (element wise)\n\nvector_multiplication <- sample_vector * colon_vector\n\n\nvector_multiplication\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  6 14 24 36 50\n```\n\n\n:::\n:::\n\n\n\n\nWe see that each first element is multiplied, each second element is multiplied and so on.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Multiply vector by a value\n\nsample_vector <- sample_vector * 3\n\n\nsample_vector\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  3  6  9 12 15\n```\n\n\n:::\n:::\n\n\n\n\nWe see that each element is multiplied by 3, like expanding a bracket!\n\n\n### Exercise\n::: {.panel-tabset}\n\n### **Exercise**{-}\n\n1. Try and add \"sample_vector\" and \"sequence_vector\".\n\n2. Can you figure out what has happened?\n\n### **Show Answer**{-}\n\n1. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Adding two vectors of different lengths\n\nvector_after_addition <- sample_vector + sequence_vector\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in sample_vector + sequence_vector: longer object length is not a\nmultiple of shorter object length\n```\n\n\n:::\n\n```{.r .cell-code}\nvector_after_addition  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  5 10 15 14 19\n```\n\n\n:::\n:::\n\n\n\n\n2. Here we have one vector with 3 elements and one with 5 elements. The number of elements in a vector is referred to as the **length** of the vector, so sample vector has length 5.\n\nWhen we try to add vectors of different lengths R gives a warning message as the **longer object length is not a multiple of the shorter object length**.\n\nAs we can see R has recycled the elements in the shorter vector, wrapped them around to reach the length of the longer one, before adding them together.\n\nWhen applying arithmetic to two vectors their lengths should either be equal, or the length of the longer one a multiple of the length of the shorter one, i.e. adding a vector of length 3 to a length 6. \n\n:::\n\n\n## Indexing a Vector \n\nOften, we want to select specific elements or ranges of them to work with going forward. \n\nElements in a vector can be selected using square brackets **[ ]**. \n\n> **We are going to use indexes, which are the position of each element within the vector.** \n\nNote that R indexes start at 1 (not 0 like other languages).\n\n## **Example - Indexing a single element**{-}\n\nTake the favourite_movies vector from the earlier exercise.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# To display the vector\n\nfavourite_movies\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Frozen\"          \"The Lion King\"   \"Moana\"           \"The Dark Knight\"\n```\n\n\n:::\n:::\n\n\n\n\nIf we want to select \"The Lion King\" from this vector, which is at position 2, we need to use the number 2 in square brackets. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Selecting the second element in the vector\n\nfavourite_movies[2] \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"The Lion King\"\n```\n\n\n:::\n:::\n\n\n\n\nReading this left to right we are:\n\n* From the favourite_movies vector\n* Select [ ]\n* The element at position 2\n\n## **Example - Index Sequentially**{-}\n\nWe can also index multiple elements using the colon operator. Remember that this creates a sequence of consecutive numbers, so allows us to index sequentially.\n\nFor example, if we wanted to select from \"The Lion King\" to \"The Dark Knight\", we select from index 2 to index 4, i.e. **2:4**.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Selecting sequentially\n\nfavourite_movies[2:4] \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"The Lion King\"   \"Moana\"           \"The Dark Knight\"\n```\n\n\n:::\n:::\n\n\n\n\n## **Example - Index out of sequence**{-}\n\nWe can even index **out of sequence**, such as obtaining the elements at indexes 1, 3 and 4. \n\nThis is interesting as most other programming languages require external packages to be able to do this, whereas R does it out of the box.\n\nTo do this, we need to create a vector of values inside the square brackets, using the c() function.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Selecting first, third and fourth items\n\nfavourite_movies[c(1,3,4)] \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Frozen\"          \"Moana\"           \"The Dark Knight\"\n```\n\n\n:::\n:::\n\n\n\n\n\n### Exercise\n::: {.panel-tabset}\n\n### **Exercise**{-}\n\nUse the vector below containing days of the week (Monday - Sunday), for the exercises.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Days of the week vector\n\ndays_of_the_week <- c(\"Monday\",\n                      \"Tuesday\",\n                      \"Wednesday\",\n                      \"Thursday\",\n                      \"Friday\",\n                      \"Saturday\",\n                      \"Sunday\")\n```\n:::\n\n\n\n\n\n1. Select Wednesday only.\n\n2. Select the week days.\n\n3. Select Tuesday and Thursday.\n\n\n### **Show Answer**{-}\n\n1. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Selecting Wednesday\n\ndays_of_the_week[3]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Wednesday\"\n```\n\n\n:::\n:::\n\n\n\n\n2. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Selecting the week days\n\ndays_of_the_week[1:5]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Monday\"    \"Tuesday\"   \"Wednesday\" \"Thursday\"  \"Friday\"   \n```\n\n\n:::\n:::\n\n\n\n\n3. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Selecting Tuesday and Thursday\n\ndays_of_the_week[c(2,4)] \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Tuesday\"  \"Thursday\"\n```\n\n\n:::\n:::\n\n\n\n\n\n### **Extension Exercise**{-}\n\nRun the following lines of code one at a time and try to determine what is happening.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Find out what the code below does\n\ndays_of_the_week[3] <- \"Wensday\"\n\n\n# Find out what the code below does\n\ndays_of_the_week[c(-6,-7)]\n\n# Find out what the code below does\n\ndays_of_the_week[8]\n```\n:::\n\n\n\n\n### **Extension Answer**{-}\n\n* The first line of code modifies the element at index position 3 and overwrites it (notice the assignment operator) to something else.\n\n* Using the minus sign when selecting elements reverses the process, i.e. tells R **not** to select that value. So here we are saying select all except index positions 6 and 7.\n\n* Giving an index position outside of the range of vector elements returns **NA (Not Available)** as there is no 8th value in the vector.\n\n:::\n\n\n# Lists \n\nLists are similar data structure to vectors in that they are an ordered collection of elements. \n\nThey differ to vectors because their elements can be of any type, including vectors and lists themselves! \n\nUnlike with vectors, where combining multiple vectors creates one vector, in lists, each element can also be a collection of elements, and no coercion or combination takes place in its creation.\n\n>**So why do you need lists?** \n\nLists enables you to gather a variety of objects with different contents and lengths under one name in an ordered way.\n\n![](Images/list.png){fig-alt=\"Visual of a list, with each element being a collection of boxes with different colours.\"}\n\nTo create a list we will use the **list()** function.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Creating a list\n\nmovies_numbers_friends <- list(favourite_movies, lucky_numbers, my_friends)\n\n# To display the list\n\nmovies_numbers_friends\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] \"Frozen\"          \"The Lion King\"   \"Moana\"           \"The Dark Knight\"\n\n[[2]]\n[1]  7 12 15  1\n\n[[3]]\n[1] \"ian\"    \"hannah\" \"mike\"   \"almas\" \n```\n\n\n:::\n:::\n\n\n\n\nEach of the contents will appear on a new line:\n\n* Starting with double-square brackets [[1]], this denotes the first element of the list, since it is a **container of containers** there are 2 levels to select from.\n* Next is the singular square bracket [1] denoting the first element of the numeric vector inside the list. \n\nThis is interesting as indexing from a list is a little more complicated.\n\n\n## Indexing from a list\n\nWe can select at two levels from lists, and this differs by what we actually **return** as a result. \n\nPreviously when we indexed from vectors:\n\n* If we selected one value, we return the value itself as a single data point.\n* If we selected a few values, we return a **vector** of those chosen values, as it is still a collection after all. \n\nWith lists:\n\n* If we select with double square brackets, **[[ ]]**, we return the collection at position 1 in this list, this could be a vector, another list, whatever the value is.\n* If we select with single square brackets, **[ ]**, we return a smaller list just containing the element we asked for. \n\n>**Let's see this in practice**\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Index to return the collection at position 1\n\nmovies_numbers_friends[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Frozen\"          \"The Lion King\"   \"Moana\"           \"The Dark Knight\"\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Index to return a smaller/sub-list with element 1 only\n\nmovies_numbers_friends[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] \"Frozen\"          \"The Lion King\"   \"Moana\"           \"The Dark Knight\"\n```\n\n\n:::\n:::\n\n\n\n\nWe can even **double-select** to select the collection with double brackets, and then a specific element or collection of elements from there.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Access \"The Dark Knight\" from the list\n\nmovies_numbers_friends[[2]][4]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n:::\n\n\n\n\nSo we access the second element of the list, which is a character vector, then the 4th element of the vector. \n\n\n# Data Frames\n\nData frames are like the tables we are used to from Excel and other programs, with columns and rows that form a 2 dimensional object.\n\nThey are collections of vectors, where:\n\n* Each vector contains the same data type\n* Subsequent vectors contain different data types (i.e. column 1 could be numeric, column 2 could be character)\n\nAs a whole, DataFrames have the following features:\n\n* Columns are variables.\n* Rows are observations (i.e. an entry for each variable forms an observation/row).\n* They can hold variables of different types.\n\n![](Images/dataframe.png){fig-alt=\"Visual of a dataframe where each column has a name.\"}\n\nTo create one, we can use the **data.frame()** function on vectors you would like to be your columns, they must be the same length.\n\n>**Using data.frame()**\n\nWithin this function, the argument we assign the vectors to becomes the column name, providing us a handy shortcut to doing these tasks separately. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a dataframe with favourite movies and numbers\n\nabout_me_df <- data.frame(numbers = lucky_numbers,\n                          movies = favourite_movies)\n\nabout_me_df\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  numbers          movies\n1       7          Frozen\n2      12   The Lion King\n3      15           Moana\n4       1 The Dark Knight\n```\n\n\n:::\n:::\n\n\n\n\nYou see that this just prints the column names and content in the console. We would need to investigate the data further to obtain other information about it.\n\nWhen it comes to working with data, these are outdated, and the **tidyverse**, which we will be introduced to in the next chapter, provide us an excellent upgrade to the data frame, known as the **tibble**.\n\nWe will see this in the next chapter.\n\n\n# Summary\n\nWe have covered a lot material in R and yet there is still so much more to cover in terms of functionality, as R has so much to offer. \n\nBy no means are you expected to remember all the above, what is better is that you understand the problems you want to solve and can then use the references or material provided (or you find yourself) to go about solving it. \n\nNext up, we will introduces packages, importing and exporting data. \n",
    "supporting": [
      "CH2_data_structures_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}