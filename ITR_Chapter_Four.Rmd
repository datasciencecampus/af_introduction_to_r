---
title: "Intro to R - Data Manipulation"
output:
  html_document: 
    theme: united
    highlight: tango
    toc: yes
    toc_float: yes
    number_sections: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
```{r, echo=FALSE}
htmltools::img(src = knitr::image_uri("./Images/LATree.PNG"),
               alt = 'logo', 
               style = 'position:absolute; top:0; right:0; padding:10px; width:200px;')
```


***

# Learning Objectives
<br>

**The goal of this session is to:**

<br>

* Understand the importance of clean variable names.

* Be able to clean column names using `janitor`or `gsub`.

* Be able to sort data.

* Be able to select data.

* Be able to filter data.

* Be able to use the mutate function and use the pipe 

* Be able to join data.

***

# Exercise {.tabset .tabset-fade}

<br>

## **Exercise**

<br>

Before we begin, could you load the packages below into your script,

- `readr`

- `janitor`

- `dplyr`


And then,

- Read in the **titanic.csv** and assign it to `titanic`

***

## **Hint**

<br>

The code below demonstrates how you can load a package.

```{r eval=FALSE}

library(package name)

```

<br>

The code below demonstrates how you can read csv data.

```{r, eval=FALSE}


dataframe_name <- readr::read_csv("file_path")



```

***

## **Show Answer**

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Load libraries

library(readr)
library(janitor)
library(dplyr)


# Read in data


titanic <- readr::read_csv("D:/Git/Intro_to_R_Refresh/Data/titanic.csv", 
                           na=c("", " ", "NULL"))


```

***

<br>

# Column Names

<br>

In the previous section we looked at reading data into R and also inspecting it. 

In this section we are going to look at how to manipulate it.

>In the previous session we stated that every column in a data frame is a variable and it is good practice to not have spaces within variable names.


This makes it easier for us to call on the variables when we need to use them.

***

## **Example**

<br>

For example if we wanted to pick the `school name` column from the school dataset. 

<br>

>The code below does not work. 

<br>

```{r, eval=FALSE}

titanic$name of Passenger

```

<br>

To get around this we enclose `school name` with back ticks like the code below (the key above the tab key on left hand side).

<br>

```{r, eval=FALSE}

titanic$`name Of Passenger`

```

<br>

If your column names have spaces and you keep them, you must use backticks.

<br>

>However its good practise to remove spaces and symbols.

<br>

We can see the column names by using the  `names()` function to access the `name` attribute of the data.

```{r}


names(titanic)


```

***

## Cleaning Column Names {.tabset .tabset-fade}

<br>

### **janitor Package**

The `janitor` package offers many functions used to manipulate data, in this session we will use the library to to clean our data set names.

>We can clean the names of our dataset with the `clean_names()` function as shown below.


```{r}

# Apply the function to the data set.

titanic <- clean_names(titanic)


names(titanic)

```

<br>

`clean_names()` removes spaces, symbols, changes characters to lower case and makes all columns start with letters.

<br>

This is the default setting, other options we could use are:

```{r, eval = F}

"snake", "lower_camel", "upper_camel", 

"screaming_snake", "lower_upper", "upper_lower", 

"all_caps", "small_camel", "big_camel", "mixed"

```

<br>

Which can be put inside the `clean_names()` function as shown below:

<br>

```{r, eval = F}

clean_names(titanic, case="snake")

```

***
 
### **gsub**

We can also do this using the function `gsub()`. `gsub()`. 

>here is used on the column names, but can be used on text columns too.

<br>

>The code below substitues in any instance of the first symbol within the "" with the second set of "".

For example, the output of `gsub(" ", "_", "piece of text")` would be `piece_of_text`.

<br>


```{r, eval = F}


# We can apply different substitution to the names of our columns.

names(titanic) <- gsub(" ", "_", names(titanic))

names(titanic) <- gsub("," , "", names(titanic) )

names(titanic) <- gsub("-" , "_", names(titanic))



```

<br>

The `tolower()` function changes a string of characters to lower case.


```{r, eval = F}

# We can lower case the names of the data frame.

names(titanic) <- tolower(names(titanic)) 


```

<br>

We can also rename column name. The first argument is the data frame to be changed, the second is the column and it's change.

<br>

```{r, eval = F}

titanic <- rename(school, age_of_passenger = age)

```

<br>

We can also use it on full columns.

 
```{r, eval = F}

# This lower cases all records in the column we have chosen.

titanic$name_of_passenger <- tolower(titanic$name_of_passenger) 


```

***

<br>

# dplyr

<br>

This is one of the most powerful tools in the *tidyverse*, which makes data manipulation simple and code easy to read.

We are going to look at the following concepts,

1. arrange/sort
2. select
3. filter
4. mutate
5. joining data

<br>

>`dplyr` functions (verbs) all have the same structure.

<br>

```{r, eval = F}

# This is the format they follow.

verb(data, more information)

```

***


## Arrange{.tabset .tabset-fade}

<br>

>`arrange()` lets you sort data by a variable.

<br>



We can sort the column `fare` with code below.


```{r}

# We input the data we want to sort, and what we are going to sort it by.


titanic_sorted <- dplyr::arrange(.data = titanic,
                          fare)


# This shows us some of the sorted data.


head(titanic_sorted$fare)


# This shows us some of the unsorted data.

head(titanic$fare)

```
<br>

>`.data` is the argument name for the data argument in `dplyr`.

<br>

>It is optional, but can help us read the code more effectively.

If we don't specify how we are sorting, the default is to sort in ascending order.

<br>

To sort in descending order, we use the code below:

```{r}

# We input the data we want to sort, and what we are going to sort it by.


titanic_sorted <- dplyr::arrange(.data = titanic,
                          desc(fare))


# This shows us some of the sorted data.


head(titanic_sorted$fare)


# This shows us some of the unsorted data.

head(titanic$fare)

```

<br>

### **Exercise**

<br>

1. Can you sort the titanic data set by age *and* fare.

<br>

2. Can you sort the titanic data set by age *and* fare in descending order for both variables.

### **Hint**

<br>

1. Can you sort the titanic data set by age *and* fare.

<br>

2. Can you sort the titanic data set by age *and* fare in descending order for both variables.

<br>

```{r, eval=FALSE}

# Sort the titanic data based on two variables.

titanic_sorted <- dplyr::arrange(.data = dataset,
                          first_variable,
                          second_variable)
                          


```

<br>

To sort both descending order we have to use `desc()`


### **Show Answer**

<br>

Sorting by multiple variables, arranged them within each other. meaning it will sort the data by `age` first and then  will sort by fare.

<br>

```{r}

# Sort the titanic data based on two variables.

titanic_sorted <- dplyr::arrange(.data = titanic,
                          age_of_passenger,
                          fare)
                          
head(titanic_sorted, n = 10)

```

<br>
To sort both descending order we have to use `desc()` around each column name.

<br>

If you only had one `desc` on the `age_of_passenger`, it will show age_of_passenger in descending order, but fare in ascending.

<br>

```{r}

# Sorting both variables in descending order.


titanic_sorted <- dplyr::arrange(.data = titanic,
                          desc(age_of_passenger),
                          desc(fare))
                          
head(titanic_sorted, n = 10)


```

***

<br>

## Select{.tabset .tabset-fade}


> `Select()` allows us to pick entire columns from our data.


Previously we selected columns using the `$` symbol and the indexing operator `[]`.

<br>

We will opt to use `dplyr` functions which allow us to keep our code efficient and readable even with complex queries.

<br>

`dplyr::select()` function, in its simplest form, takes two parameters. 

The first, like all `tidyverse` functions, being the tibble we are interested in, and the second being the column name.

<br>

```{r}

titanic_one_variable <- dplyr::select(titanic, 
                                      name_of_passenger)


titanic_one_variable

```

<br>

This has returned the `name_of_passenger` column from `titanic` in the form of a tibble. 

<br>

The `select()` function, like the majority of `tidyverse` functions, offers a lot of flexibility. This allows us to achieve the same result using a number of different methods, without it being clear which method is more fitting. With great flexibility, comes great uncertainty...

<br>

If we want to select multiple columns, we have to first collect the column names together using a character vector, and then pass that as our second parameters. 

<br>

>Alternatively, we could just write out all the column names we want.

```{r}

titanic_three_variables <- dplyr::select(titanic,
                                         c("name_of_passenger", "age_of_passenger", "pclass"))

titanic_three_variables

```

<br>

The real power of the `select` function comes from its flexibility.

<br>

For example, suppose we wanted to select all columns excluding `name`, `age` and `pclass`. We could type all the columns names we need, or instead:

<br>

```{r}

titanic_minus_three_variables <- dplyr::select(titanic, 
                                               -c("name_of_passenger", "age_of_passenger", "pclass"))

titanic_minus_three_variables

```

<br>

We can also select the columns using numbers, positive numbers and negative numbers to drop.

<br>

For example the code below will select the first 4 columns and then column 7.

<br>

```{r}
# We can both use regular sequences with ":" and specific numbers.

titanic_number_select <- dplyr::select(.data = titanic, 
                                       c(1:4, 7))

titanic_number_select
                    
                    
```

<br>

In this example we select all columns, except column 2.

<br>

```{r}

# The negative indicates which columns we do not want.

titanic_number_select <- dplyr::select(.data = titanic, 
                                       c(-2))
                    
titanic_number_select                    
```

<br>


This flexibility is further enhanced by the `select helper` functions. 

<br>

>These are functions which allow you select columns based on their names.

<br>

* `starts_with(match)`: Starts with a prefix.
* `ends_with(match)`: Ends with a suffix.
* `contains(match)`: Contains a literal string.
* `matches(match)`: Matches a regular expression.
* `num_range(num_vector)`: Selects columns which matches a numeric range with a prefix e.g. "col1", "col2", "col3",...
* `one_of(char_vector)`: Selects columns which are in the given character vector.
* `everything()`: Selects all variables.
* `last_col()`:  

<br>

These functions are passed after the first parameter. e.g.

```{r}
titanic_starts_with <- dplyr::select(titanic, starts_with("s"))

titanic_starts_with
```
<br>

Or:


```{r}

titanic_matches <- dplyr::select(titanic, name_of_passenger, matches("."))

titanic_matches
```

<br>

It is important to note, all `tidyverse` functions work on and return a copy of the original data. More often than not, the returned object is another `tibble`, even if it's a single column. 

### **Exercise**

<br>

1. Can you select from the titanic data set, the second, third and fourth columns.

<br>

2. Can you select the columns, pclass, survived, name_of_passenger, sex_of_passenger, age_of_passenger and embarked.

<br>

3. Can select just the last column.

<br>

4. Can you select the columns that end the word "passenger".

<br>

5. Can you select, name_of_passenger, age_of_passenger and everything else

***

### **Hint**

***
### **Show Answer**
***

