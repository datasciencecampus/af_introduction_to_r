---
title: "Intro to R - Chapter Six "
output:
  html_document: 
    theme: united
    highlight: tango
    toc: yes
    toc_float: yes
    number_sections: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
```{r, echo=FALSE}
htmltools::img(src = knitr::image_uri("../Images/LATree.PNG"),
               alt = "logo", 
               style = "position:absolute; top:0; right:0; padding:10px; width:200px;")
```

<br>

```{r message=FALSE, warning=FALSE, include=FALSE}

library(tidyverse)

library(janitor)

library(kableExtra)

# Importing CSV data using readr package and read_csv function
# Specifying missing values by adding a vector, 
# na = c() of what should be 
# classed as missing values

titanic <- readr::read_csv("../Data/titanic.csv", 
                           na = c("", " ", "NULL"))

# To display the data
titanic

# Clean column names
titanic <- clean_names(titanic)



```


***
# Control Flow and Functions{-}

***

<br>

# Learning Objectives

**The goal of this chapter is to:**

* Be able to use loops: *for* loops.

* Be able to use conditional statements: *if*, *else* and *else if*.

* Learn what functions are.

* Understand why we need to use functions.

* Be able to write functions.

* Have a basic understanding of scoping within functions.


***

<br>

# Programming Basics

We use R because its great for data analysis, data visualization communicating results. However, R is not just a data analysis environment but a programming language. Advanced R programmers can develop complex packages and even improve R itself.

Programming is basically giving instructions to a computer.

In this chapter, we introduce three **key programming concepts: conditional statements, loops, and functions**. These are not just key building blocks for advanced programming, but are sometimes useful during data analysis.

***

<br>


# Loops

Loops are a fundamental concept in traditional programming languages. 


A loop is a way to repeat a number commands until a given condition is met.

This repetition of code is called iteration.


Since R is a vectorised language, loops are not as prominently used in R as in Python for example. Despite this, they are a key part of programming in general and can save you a  large amount of time and typing in certain cases.

They allow you to automate parts of your code that are in need of repetition.

Similar to how functions help make our code more abstract and general, loops are similar. As we are essentially simplifying a specific case to a more general case.

We are going to look at `for` loops. 

***

<br>

## For Loops

These are the most common type.

They follow the basic structure below.


```{r, eval=FALSE}

# Basic Structure of a loop

# Create an empty output
# This is for effiency as loops are known to
# Run quicker when output is defined
# Which we will fill when the loop runs

# Create an empty vector

output <- c()

# Creating the loop

for (each_item in my_iterable) { 
  
  output <- commands
  
}

```

<br>


* First we create an empty vector for our output.

* Then we start with the loop with the word `for`,

* Followed by `()` brackets where we specify an index variable, `i` is commonly used but it can be anything that you want. This is a place holder and will correspond to a different element for each part of the loop,

* Then the word `in`.

* Then specify an iterable. This could be a `vector`, a `list`, a `dataframe` etc. An iterable is an object that can be iterated through, one element at a time. 

* Followed by the `{}` curly brackets, which will have our commands, these could be multiple lines of code.

***

<br>

### Example

Let's look at an example.

We start by creating an iterable, I have created a vector with **numbers between 0 and 5**.


```{r}
# Creating a vector

example_vector <- c(0, 1, 2, 3, 4, 5)

```

We can then create our loop.

```{r}
# Create an empty output
# Which we will fill when the loop runs

result <- c()

# Creating the loop

for (each_number in example_vector) {
  
  print(each_number * 2)
  
  result <- append(result, values = each_number * 2)
  
}

# To display the data

result

```

<br>

This loop is taking each number in our example vector and multiplying it by 2. It is both printing out that value, and storing it in the result vector. 

The keyword `for` is followed by a variable that refers to each item in my iterable. I’ve called this variable **`each_number`**. It is good to be clear and explicit when naming variables, so they explain what the variable is. 

You’ll often see letters like `i` used here, which is not particularly clear.

The keyword `in` is followed by the iterable I want to loop over (here it is `example_vector`).

My command is assigned to `result`. The command here is to multiply each number in `example_vector` by 2.


The **`append()`** function simply adds an element to a vector, we first specify the vector we want to add to which is `result` and then specify the values that we want to add to it, within the function this is set to the argument `values`.




***

<br>


Although it is useful to know how to use loops in R, it is often faster to accomplish the same thing using vectorised operations in R. 

We already saw examples in the Vector Arithmetic section. A vectorized function is a function that will apply the same operation on each of the vectors.

For example,

```{r}
# Creating a vector

example_vector <- 1:5

# Using a sqrt() function on our vector

sqrt(example_vector)
```

<br>

To make this calculation, there is no need for a loop. However, not all functions work this way. 


While there are many functions out there that vectorize particular calculations, there are still some tasks that cannot be vectorized. This is where iteration becomes useful. While we should always be looking to vectorize calculations, we can take comfort knowing that we have a back up tool to use just in case it fails us.

We also have while loops, which are used to loop until a specific condition is met. 

You can a find a tutorial on them here, [While Loop](https://www.datamentor.io/r-programming/while-loop/).

<br>

### Exercise loops{.tabset .tabset-fade}


#### **Exercise**{-}

1. You are given a vector of measurements that are grams (g). For this exercise, we    actually want to convert all of these measurements to kilograms (kg). 

   For reference, 1kg is the same as 1000 grams.

   Using a for loop, create and append to a new vector called kilo_grams that contains the          values converted to meters.

```{r}
# Vector 

grams <- c(100000, 7899900, 967312, 49185, 6100)


```




***

<br>


#### **Hint**{-}

1. You are given a vector of measurements that are grams (g). For this exercise, we    actually want to convert all of these measurements to kilograms (kg). 

   For reference, 1kg is the same as 1000 grams.

   Using a for loop, create and append to a new vector called kilo_grams that contains the          values converted to meters.

```{r}
# Vector

grams <- c(100000, 7899900, 967312, 49185, 6100)

# Empty vector for storage

kilo_grams <- c()

# For loop

for (measurement in grams) {
  
  converted_kilo_grams <- measurement / 1000
  
  kilo_grams <- append(kilo_grams, converted_kilo_grams)
  
}


# To display the data

kilo_grams

```



***

<br>


#### **Show Answer**{-}

1. You are given a vector of measurements that are grams (g). For this exercise, we    actually want to convert all of these measurements to kilograms (kg). 

   For reference, 1kg is the same as 1000 grams.

   Using a for loop, create and append to a new vector called kilo_grams that contains the          values converted to meters.

```{r}

# Vector

grams <- c(100000, 7899900, 967312, 49185, 6100)

# Empty vector for storage

kilo_grams <- c()

# For loop

for (measurement in grams) {
  
     converted_kilo_grams <- measurement / 1000 # Converting grams to kg
  
     kilo_grams <- append(kilo_grams, converted_kilo_grams) # Appending to kilo_grams vector
  
}

# To display the data

kilo_grams

```



***

<br>

# Conditional Statements

***

## If, Elseif, Else

A conditional statement will check whether a condition is TRUE or FALSE.

So, if our statement meets this criteria apply this action, otherwise do nothing.

This is useful if we want a function to run only when our data meets certain conditions, this is termed `control flow`.

Control flow is something we do in everyday life. 

For example when we go shopping and choose fruits, we normally want to buy the ones that look juicy and healthy and avoid the ones that look rotten or bruised. As we pick up our fruit and inspect it, we are actually using control flow.


![Image showing Control Flow](../Images/control_flow_image.png)

<br>



In order to move through this decision process, we need to answer either "Yes" or "No" to each question. A series of "Yes" answers will lead us to buy an orange that matches our set criteria.

This links in with logical or bolean data types that we covered in Chapter One, Getting Started With R. As our statement has to be either `TRUE` or `FALSE`. To evaluate these we use comparison operators which we used in Chapter Working With Dataframes where we used the `filter()` function.


We use comparison and logical operators.

<br>

**Comparison Operators.**

| Operator | Description | 
| ------ |:------| 
|   ==   | equal to | 
|  !=    | not equal to |   
| <      | less than|
| >      | greater than |
| <=     | less than or equal to|
| >=     | greater than or equal to|


<br>


**Logical Operators.**

| Operator| Description| 
| ------  |:------:| 
|   &     | And | 
|   \|    | Or |
|    !    | Not|



<br>

Our example above shows that we can make a decision by answering "Yes" or "No" (2 branches). But most of the time this will not be the case. We can add some more branches to our responses.


R provides a way to incorporate more than two branches in an if statement with the else if keyword. The else if keyword provides another code block to use in an if statement, and we can have as many as we see fit.


we use the:


- `if` statement

- `else if` statement

- `else` statement


`if`, `else if` and `else` are not loops, but fall under the category of control flow.

These take a conditional argument, and if that is met (evaluates to `TRUE`) then the associated action is completed.

If the condition is not met it will move to an `else if` (if present) and if that condition is met the associated action will be completed.

Finally, if none of the conditions is met the actions for the `else` condition is met.



```{r, eval=FALSE}

if (first logical condition) { 
  
  Commands - executed if logical condition is true
  
} else if (second condition) { 
  
  Commands - executed if the logical condition is false and second condtion is true
  
} else {
  
  Commands - executed when all conditions are false
  
}

```

>**It’s important that the `else if` keyword comes on the same line as the closing bracket of the previous part of the control structure.**

<br>

![Image flow of if, elseif and else](../Images/control_flow_if_elseif_and_else.png)

<br>


Let's look at an example.

We can just have an `if` and an `else`.



```{r}

height <- 6

if (height == 5) { 
  
  print("We're the same height")
  
} else {
  
  print("Your height is different")
  
}

```

<br>

Remember our `if`, `else if` and `else` statements take a condition so we need a double equals sign (`==`) for checking equivalence.
If the first criteria isn’t met it will move to the else statement and action that.

We can add in more choices using an `else if` statement.

```{r}

height <- 7

if (height == 5) { 
  
  print("We're the same height")
  
} else if (height == 7) { 
  
  print("You're tall!")
 
} else {
  
  print("Your height is different")
  
}

```



<br>



Within these we can use our logical operators too: `&` (and); `|` (or).


Here we want the action to happen if the value is greater than 7 and less than 10.

```{r}

height <- 9

if (height == 5) { 
  
  print("We're the same height")
  
} else if (height > 7 & height < 10) { 
  
  print("You're tall!")
  
} else {
  
  print("Your height is different")
  
}

```


<br>

It’s important to know how the `if`, `else if`, `else` works.

Below we have two options for when the value is 5. However it will only print out  “We’re the same height!” When the condition is met it performs the action associated with it and then stops.

Try changing the value stored in `my_height` to see the other results.


```{r}
height <- 5

if (height == 5) { 
  
  print("We're the same height")
  
} else if (height > 7 & height < 10) { 
  
  print("You're tall!")
  
} else if (height == 5) {
  
  print("Wow, it's still 5!")
  
} else {
  
  print("Your height is different")
  
}
```

***

<br>

## Loops and Conditional Statements

We can combine a `loop` with `if else` statements.

* We have a vector, with values from `1-7` and assign it to `number_of_takeaways_ordered`.

* And a `for` loop with an `if` and `else` statement shows that if you order more than `2` takeaways a week it will print `"too many"` and if you order less than two it prints `"enough"`.

```{r}

number_of_takeaways_ordered <- c(1, 2, 3, 4, 5, 6, 7)

for (number in number_of_takeaways_ordered) { 
  
  print(number)
  
  if (number > 3) { 
    
    print("too many")
    
  } else { 
    
  print("enough")
    
  }
}

```

***

<br>


### Exercise{.tabset .tabset-fade}



#### **Exercise**{-}

1. Can you write a loop with an `if`, `else if` and `else` statement, that loops through the numbers from 1 to 30.

   If the number is a multiple of both 3 and 5, print "FizzBuzz".

   If the number is a multiple of 3, print the word "Fizz".

   If the number is a multiple of 5, print the word "Buzz".

   For all other values print the number.

Note: You can use the modulus operator for this - this is the **`%%`** in R, and shows us our remainder.

For example checking if something is divisible by 3 we can do:

```{r}
# Example of Modulo
# Returns FALSE (10 / 3 has a remainder of 1 - so does not have a remainder of 0)
10 %% 3 == 0

```

```{r}
# Second example of Modulo
# Returns TRUE (9 / 3 has a remainder of 0)
9 %% 3 == 0

```

***

<br>


#### **Hint**{-}

1. Can you write a loop with an `if`, `else if` and `else` statement, that loops through the numbers from 1 to 30.

   If the number is a multiple of both 3 and 5, print "FizzBuzz".

   If the number is a multiple of 3, print the word "Fizz".

   If the number is a multiple of 5, print the word "Buzz".

   For all other values print the number.

```{r, eval=FALSE}

for (each_number in vector) { 
  
  if (first conditions) {
    
    output
    
  }else if (second condition) {
    
    output
    
  }else if (third condition) { 
    
    output
    
  }else {
    
    print(each_number)
    
  }
  
}

```

***

<br>

#### **Show Answer**{-}

1. Can you write a loop with an `if`, `else if` and `else` statement, that loops through the numbers from 1 to 30.

   If the number is a multiple of both 3 and 5, print "FizzBuzz".

   If the number is a multiple of 3, print the word "Fizz".

   If the number is a multiple of 5, print the word "Buzz".

   For all other values print the number.

```{r}

# I have used i as the index variable here
# This is the most commonly used 
# But for best practice i recomment to set it
# to be something more relevant

for (i in 1:30) { 
  
  if (i %% 3 == 0 & i %% 5 == 0) {
    
    print("FizzBuzz")
    
  }else if (i %% 3 == 0) {
    
    print("Fizz")
    
  }else if (i %% 5 == 0) { 
    
    print("Buzz")
    
  }else {
    
    print(i)
  }
  
}

```

***

<br>


## Dplyr If_else

We have seen how we can use the  if statement  to create branching paths in our code. A singular if statement is useful if we need to perform different code for a single condition, but it's not useful in cases where there are a lot of values that need comparison.

dplyr has a function called `if_else()`

The if_else() function is designed to be used with multiple values, like with a vector or a column in a tibble.

lets look at the help information on the function to see what arguements we can specify.

>**I would strongly advice to look at the R help documentation when you come across a function you have not used before.**

```{r}

# Looking at the help documentation

?if_else

```

Looking at help documentation for the function, we can see that it needs 3 main arguements.

1. condition.
A statement (e.g. comparison operator) that evaluates to TRUE or FALSE. Instead of passing it a single value, you need to give it a specific column in the data.

2. true
The value that the new column should take if the comparison operator is TRUE. This can be anything that we specify. 

3. false
The value that the new column should take if the comparison operator is FALSE. Like the second argument, it can be anything you specify.


lets look at an example.

We will use the titanic dataset, let see if there is any missing values in our dataset.
Here I am using the function `anyNA`, which will return `TRUE` if there are any missing values and `FALSE` if there are no missing values.

```{r}

# Checks if there are missing values in our data

anyNA(titanic)

```

No that we know they are missing values in the data, we can use the `summary` function to see how many missing values we have.

```{r}

# To get sum of missing values

colSums(is.na(titanic))



# Summary of our data

summary(titanic$age_of_passenger)



```

We can see that the column `age_of_passenger` has 267 missing values.

We can impute(populate) our missing values using the dplyr `if_else` function. Here am going to use the mean value for `age_of_passenger`.

>**Please refer to the Editing and Imputation Course for details on how to best impute your missing data, this is demonstration purposes only.**

As we saw in Chapter Four - Working with Dataframes, the mutate function from the dplyr package is useful in creating a new variable. 

We don't necessarily want to change the original column so we can create a new variable without the NA. mutate is easy to use, we just choose a variable name and define how to create this variable.

Here my new column name is imputed_age_of_passenger.

The if_else() function takes that single comparison operator condition = is.na(age_of_passenger) and vectorizes it.

```{r}

# Dealing with missing values
# we can omit
# we can immpute(populate)
# here using the mean

imputed_titanic <- titanic %>%
                 # New column name                        # Condition to be met
  dplyr::mutate(imputed_age_of_passenger = dplyr::if_else(condition = is.na(age_of_passenger),
    
    # What to do when true
    true = mean(age_of_passenger, na.rm = TRUE),
    
    # What do to when false
    false = age_of_passenger
    )
  )

# To Display the output
summary(imputed_titanic$imputed_age_of_passenger)

```

>**If you need to more complicated conditions you could the case_when function from dplyr**.

## Dplyr Case when

So far we have looked at else if to add more options to an if statement.

We have also used the  the `dplyr::if_else()` function, but it works best with simpler conditions that evaluate to `TRUE` or `FALSE`.

We can  put multiple `dplyr::ifelse()` commands inside each other but this makes code hard to read and not recommended.

If we are dealing with multiple complex conditions dplyr also has a function called `dplyr::case_when`

You can think of the case_when() function as a generalization of the `dplyr::if_else()` function, which incorporates more branches.

This command takes multiple conditions and tests them in order.

case_when() takes a conditional command in the same format as the first command in ifelse(), however only the action for the TRUE condition is given, separated with a tilde ~.

lets look at an example.



```{r}
case_when_example <- titanic %>% 
  mutate(
    country_embarked = case_when(
      embarked == "S"  ~ "England",
      embarked == "C" ~ "France",
      embarked == "Q" ~ "Ireland",
      TRUE ~ "Unknown") 
  )

```


```{r echo = FALSE, message = FALSE, warning = FALSE}

# To display just part of the dataset



case_when_example %>%
  select(embarked, country_embarked, everything()) %>% 
  kable() %>% 
  kable_styling(bootstrap_options = c("striped", "hover", "condensed")) %>% 
  scroll_box(width = "100", height = "500px")
```

Another example is when we did the FizzBuzz exercise.

```{r}
# I have used i as the index variable here
# This is the most commonly used 
# But for best practice i recomment to set it
# to be something more relevant

for (i in 1:30) { 
  
  if (i %% 3 == 0 & i %% 5 == 0) {
    
    print("FizzBuzz")
    
  }else if (i %% 3 == 0) {
    
    print("Fizz")
    
  }else if (i %% 5 == 0) { 
    
    print("Buzz")
    
  }else {
    
    print(i)
  }
  
}
```


This can be simplified using `dplyr::case_when()` as below.

Key thing to keep in mind is arguements are evaluated in order.


```{r}
i <- 1:30

case_when(
  (i %% 3 == 0 & i %% 5 == 0) ~ "FizzBuzz",
  (i %% 3 == 0) ~ "Fizz",
  (i %% 5 == 0) ~ "Buzz",
  TRUE ~ as.character(i)
  )
```




<br>

### Exercise Case When{.tabset .tabset-fade}


#### **Exercise**{-}

1. Use the case_when() function to create a new column in the titanic dataset called fare_level. This new column should have 4 levels total:
If fare is less than 100, fare_level should be "cheap"
Between 100 and less than 200: "fair"
Between 200 and less than 300: "expensive"
Greater than or equal to 300: "Very expensive"
Assign your tibble with the new column to the variable titanic_fare_level.





***

<br>


#### **Hint**{-}

1. Use the case_when() function to create a new column in the titanic dataset called fare_level. This new column should have 4 levels total:
If fare is less than 100, fare_level should be "cheap"
Between 100 and less than 200: "fair"
Between 200 and less than 300: "expensive"
Greater than or equal to 300: "Very expensive"
Assign your tibble with the new column to the variable titanic_fare_level.

```{r}

titanic_fare_level <- titanic %>% 
  mutate(
    fare_level = case_when(
      between(fare, left = 0, right = 100)~ "cheap",
      between(fare, left = 100, right = 200) ~ "fair",
      between( fare, left = 200, right = 300) ~ "expensive",
      fare > 300 ~ "very expensive"
      )
       
  )

```




***

<br>


#### **Show Answer**{-}

1. Use the case_when() function to create a new column in the titanic dataset called fare_level. This new column should have 4 levels total:
If fare is less than 100, fare_level should be "cheap"
Between 100 and less than 200: "fair"
Between 200 and less than 300: "expensive"
Greater than or equal to 300: "Very expensive"
Assign your tibble with the new column to the variable titanic_fare_level.

```{r}

titanic_fare_level <- titanic %>% 
  mutate(
    fare_level = case_when(
      between(fare, left = 0, right = 100)~ "cheap",
      between(fare, left = 100, right = 200) ~ "fair",
      between( fare, left = 200, right = 300) ~ "expensive",
      fare > 300 ~ "very expensive"
      )
       
  )

```


```{r echo = FALSE, message = FALSE, warning = FALSE}

# To display just part of the dataset



titanic_fare_level %>%
  select(fare_level, fare, everything()) %>% 
  kable() %>% 
  kable_styling(bootstrap_options = c("striped", "hover", "condensed")) %>% 
  scroll_box(width = "100", height = "500px")
```



***

<br>



# Functions



A function is a bit of code which, when called, performs a task. It can take various inputs, called arguments, and return outputs.

Base R includes numerous built-in functions and there are thousands more R functions in packages available on CRAN and elsewhere.

We have previously used ready-made functions (from Base R or from packages), e.g. **`mutate()`**, **`help()`**,**`round()`**,**`clean_names()`**, **`mean()`**.

You can also write your own functions, called “user-defined functions”.

***

<br>

## Why we use functions

* They make code shorter and easier to understand.

* They make it easier to update code, as we only need to change one place.

* Functions allow us to easily repeat similar tasks.

* They help reduce errors caused from copied and pasted code.


<br>


Up until now we've been writing code line by line and running it sequentially. As effective as this has been, things can get messy as we scale up to larger problems.

We can avoid messy code by organising it into chunks of reusable code called functions. This allows us to create blocks of code dedicated to performing a specific procedure or task. We can then 'call' this function to perform its specific task as and when needed. Understanding why and how to write functions is an important part of writing code that is consistent, readable and reproducible.

In addition to this, we use functions to do everything in R - from making a vector to creating models and plots. Having more hands on experience with functions can give you a greater appreciation for how the functions, we heavily depend on, are implemented.


We can take one complicated operation and wrap it up inside a function and use it wherever we need. 

For example, take the mean() function from base R that calculates the average value of a given vector — we could write out the average calculation by hand:

```{r}

# Creating a vector

numbers <- 1:19

# Calculating the mean 
# Here I am using the sum function and the length function

mean_numbers <- sum(numbers) / length(numbers)

# To Display the data

mean_numbers


# Using the mean function

mean(numbers)


```

Nothing stops us from writing out sum(numbers) / length(nummbers) every time we need to calculate an average.

Using the mean function is much easier.

Another example here is in Chapter Four- Working with DataFrames when we cleaned our column names, it was much easier to use the `janitor::clean_names()` function than to run 4 lines of code using `gsub()`

***

<br>


## Types of Functions

In R we have three types of functions:

1. **'Predefined' Functions**

   We have already used several of these, such as **`c()`**, **`round()`**, **`print()`**, etc. These functions, like the name suggests are built into R and are always available as we have seen by pressing tab in the console. 

2. **'User-defined' Functions** 

   These are functions created by us to carry out a specific task. Declared using `function()`.
   
   
3. **Anonymous Functions** – User defined - generally one line functions used within a larger piece of code, no name, but still do stuff.


In this section we’re going to focus on User Defined functions.

***

<br>
    
## How to write a function

Basic structure of a function looks like below,

```{r, eval=FALSE}
# Basic structure of a function

function_name <- function(input) { 
  
  statements of what the function is doing
  
  return(the function output)
  
}

```

<br>

>**In R, we use a function to make a function!.**

We use **`function()`** to create a function and assign it to the object `function_name`.

In the same way we use the **`list()`** function to create and return a list object, the **`function()`** function will create and return a function object.

The code for the task you want your function to perform goes inside the curly brackets {}, and the object you wish the function to work on goes inside the parenthesis().

The **`return()`** function will return whatever value is after it. When this is executed the function will stop at that line and return the given value. 

>**No code after the return statement will be executed**

Note that the keyword return is not necessary; but any function without a `return` statement will return a value of `None` - it will produce no output for future code to work with. This could be useful if you just want to print out some results to the console, or display a graph, without returning any data.

***

<br>

## Example of a basic function

```{r}
# Here is a simple function to add together two values and return the sum.

function_sum_values <- function(value_1, value_2) { 
  
  result <- value_1 + value_2
  
  return(result)
  
}

```

Our new function **`function_sum_values()`** will exist in our global environment which can be seen in the panel on the right hand side.

<br>

### Calling Functions

Calling user defined functions works the same way as calling the built-in functions we've used so far. Simply, type the function name followed by parentheses containing any required arguments.

```{r}
# I can now run my function

function_sum_values(value_1 = 1, value_2 = 2)

# Calling the function by itself prints the result to the console
# Alternatively the result can be saved as a new variable

my_result <- function_sum_values(value_1 = 3, value_2 = 4)

#To display the data

my_result

```

>**TIP - If you have written a chunck of code that you want to turn into a function, highlight the code chunk and press `Ctrl + ALt + x` on windows  or `control + option X` on a Mac.
A pop up will appear that will ask you to select a function name and the inputs and code strucutre needed to turn your code into a function will be added automatically.**




***

<br>

## Exercise{.tabset .tabset-fade}

### **Exercise** {-}

1. The **`range()`** in R, doesn't show the difference between the highest value and the lowest value, but rather shows the highest value and lowest values, can you create a function called **`my_range()`** which return the difference between the highest value and the lowest value?

```{r}
# Creating a vector

age_vector <- c(10, 23, 30, 50)

# Calling the range function on the vector

range(age_vector)

```

<br>

2. Write a function which:

   **Converts from Fahrenheit to degrees Celsius using the equation    below.**

$$C=\frac{5}{9}(F - 32)$$

> Examples: 

* `fahrenheit_to_degrees_celsius(32)` returns:
    + [1] 0

* `fahrenheit_to_degrees_celsius(11)` returns:
    + [1] -11.7

* `fahrenheit_to_degrees_celsius(81.3)` returns: 
    + [1] 27.4
    
    
   
***

<br>

### **Hint**{-}


***

<br>

### **Show Answer**{-}

1. The **`range()`** in R, doesn't show the difference between the highest value and the lowest value, but rather shows the highest value and lowest values, can you create a function called **`my_range()`** which return the difference between the highest value and the lowest value?

```{r}
# Creating my function

my_range <-  function(age_vector){
  
  result <- max(age_vector) - min(age_vector) 
  
  return(result)

}

# Running the base R range function

range(age_vector)

# Running my custom range function

my_range(age_vector)
```


Write a function which:

1. **Converts from Fahrenheit to degrees Celsius using the equation below.**


$$C=\frac{5}{9}(F-32)$$

```{r}

# Creating our function

fahrenheit_to_degrees_celsius <- function(fahrenheit) {
  celsius <- (5 / 9) * (fahrenheit - 32)
  return(celsius)
}

# Calling our function

fahrenheit_to_degrees_celsius(32)
```


***

<br>


## Scope

It’s important to notice here that the variables I create within my functions are not available outside of my function.

In R storage is broken down into environments and then scopes. Most of the time you'll be working in the global environment (right-hand panel).

In the global environment, there are two types of scopes, _global_ and _local_. Variables that have _global_ scope are visible everywhere - in every function, loop, conditional, basically every part of the code. However, variables that have _local_ scope are only visible inside said the scope and hence can only be used within that local scope.

When we create a new function we effectively create a new local scope – so the variables we declare within our functions are only available within that local scope.

Here is a classical example to demonstrate this.

```{r}

# Creating a function

example_function <- function() {
  
  z <- 10
  
  paste("This is z inside the function: ", z)
  
}

# Calling a function

example_function()

```

```{r, eval=FALSE}
# To display the result
# This will not work as this does not exist outside the function

print(z)

```

***

<br>

## Arguments

In short, arguments are things you pass to a function, when you call it, to enable the function to perform it’s task.


### Types of Arguments{-}

***
<br>


#### Required Arguments{-}

Like the name suggests, these are arguments which are required by a function and must be passed in the correct order.

``` {r}
# Creating our function

arithmetic <- function(a, b) {
  
  return ((a ^ b) / b)
  
}

# Calling our function

arithmetic(a = 4, b = 9)
```

`a` and `b` are both required arguments. We would get a missing error if we did not pass both arguments. 

***

<br>


#### Default arguments{-}

This is where, in the function declaration, the value of the parameter is pre-set. The function will retain this value unless it is changed when the function is called.
    
```{r}
# Creating our function

arithmetic <- function(a, b = 1) {
  
  return ((a ^ b) / b)
  
}

# Calling our function

arithmetic(a = 5)


# Calling our function

arithmetic(a = 5, b = 2)

```
    
In the first example above the function will take `a = 5` and use the default value `b = 1`. Whereas, in the second example, we overwrite `b = 1` by passing the argument `2`.

***

<br>


#### Dot-dot-dot arguments{-}

This is also known as the ellipsis argument.

You will often see in list of arguments a function takes, in the documentation, this `...`. This is a special argument which captures any number of arguments that aren't otherwise matched. 


Sometimes being able to pass an arbitrary number of arguments can be useful, especially when another function is called within a wrapper function. This requires the ellipsis construct, ..., which is designed to pass a variable number of arguments to a function. Here’s an example:

```{r}

# This function produces a plot of x vs y

plot_x_and_y <- function(x, y, ...) {
  
  plot(x, y, ...)
  
}

# Creating Vectors

x <- 1:10

y <- (1:10) * 2


# The function can be called with only the required arguments:

plot_x_and_y(x, y)


# Or the function can be called with any optional arguments accepted by the plot function:
# col to change the colour
# type to change the style of the line here "s" is for steps
# xlab to change the label for x axis
# ylab to change the lable for the y axis

plot_x_and_y(x, y, col = 'red', 
                   type = 's', 
                   xlab = "This is my X label",  
                   ylab = "This is my Y label")

```



***

<br>

## Example

**Descriptive Statistics Example**

For example if you wanted get the summary statistics below; We could use the summarise function.

* `min()`
* `max()`
* `mean()`
* `length()`
* `sd()` 

```{r}
# Using Summarise function to get descriptive statistics
# We first specify our dataset using the .data arguement
# The using the descriptive statisitcs functions
# Also specify na.rm = TRUE to not include missing values 
# within the calculations of the descriptive statistics

summarise(.data = titanic, minimum = min(age_of_passenger, na.rm = TRUE),
                           maximum = max(age_of_passenger, na.rm = TRUE),
                           mean = mean(age_of_passenger, na.rm = TRUE),
                           length = length(age_of_passenger),
                           standard_deviation = sd(age_of_passenger, na.rm = TRUE)
                           )


```

<br>

If we wanted the same descriptive statistics for a different column we could copy and paste the code about and change the column name.

```{r}
# Using Summarise function to get descriptive statistics
# We first specify our dataset using the .data arguement
# The using the descriptive statisitcs functions
# Also specify na.rm = TRUE to not include missing values 
# within the calculations of the descriptive statistics

summarise(.data = titanic, minimum = min(fare, na.rm = TRUE),
                           maximum = max(fare, na.rm = TRUE),
                           mean = mean(age_of_passenger, na.rm = TRUE),
                           length = length(fare),
                           standard_deviation = sd(fare, na.rm = TRUE)
                           )

```


<br>

If we we wanted another column we could keep on copying and pasting, copying and pasting but this is not recommended as its not effiecint and could lead to errors as above did above.

>**did you notice the error?**

<br>

To prevent this issue we can write our own function which will combine all these descriptive statistics into one function.

* Our function name is my_descriptive_statistics

* Our input will be column, which will be the column that we are interested is seeing the descriptive statistics for.

* My statements are the calculations for the desciptive statistics

* My return value will be a tibble of my descriptive statistics.



```{r}
# Creating my function

my_descriptive_statistics <- function(column) {
  
  # Create an object "my_minimum" which contains the min of column
  my_minimum <- min(column, na.rm = TRUE)
  
  # Create an object "my_maximum" which contains the max of column
  my_maximum <- max(column, na.rm = TRUE)
  
  # Create an object "my_mean" which contains the mean of column
  my_mean <- mean(column, na.rm = TRUE)
  
  # Create an object "my_length" which contains the length of column
  my_length <- length(column)
  
  # Create an object "my_standard_deviation" which contains the sd of  column
  my_standard_deviation <- sd(column, na.rm = TRUE)
  
 # Combine the objects created into a tibble
 return(tibble(my_minimum,
               my_maximum,
               my_mean,
               my_length,
               my_standard_deviation)
   )
  
}

```


we can now use our function on different columns, without needing to copy and paste our code.

```{r}
# Calling our function
# Here we can use it on different columns


my_descriptive_statistics(titanic$parch)

my_descriptive_statistics(titanic$sibsp)
```



***

<br>



## Applying Functions using `purrr`

Often when working with data, we want to manipulate multiple columns of data at once.

As an example using our  `my_descriptive_statistics()` on mutliple columns at the same time - how would we achieve this? 

<br>

### Functionals in R

In R, functionals are functions which take a function is as an input and returns a vector (or similar) as output.

R being a functional programming language is packed with functionals. We will introduce the following:

* `purrr::map()`
* `purrr::modify()`

There are functionals in base R as well such as: `apply`, `sapply`, `vapply`, etc which are worth experimenting with as well. We will continue with our tidyverse theme and demonstrate the `purrr` equivalents. 

`map()` and `modify()` will take a function in as an argument and apply it to every element of the given collection (e.g. vector, list).

As an example we can use the `typeof()` function to see the data types of each of our columns in the titanic dataset


```{r}


purrr::map(titanic, typeof)
```

In that example we used a built-in function `typeof`. 

All the functionals listed above also work with user defined functions.


```{r}
titanic %>% 
  dplyr::select(age_of_passenger,fare) %>% 
  purrr::map(my_descriptive_statistics)
```

### `map` vs `modify`

There is not a lot of difference between `map` and `modify`. `map` will return a list by default, whereas, `modify` always returns the same type as the input object.

```{r}
map(titanic, typeof)
```
```{r}
modify(titanic, typeof)
```
As you can see, their difference sounds subtle but the effects are not.

***

<br>


# Summary - Control Flow and Functions

***

## Reminder of Learning Objectives{-}

<br>

**You should now be able to**

* Be able to use conditional statements: *if*, *else* and *else if*.

* Know what functions are and why they are useful.
* Distinguish between a function's parameters and arguments.
    * Including different types of arguments
* Understand the idea of 'scope'.
    * i.e. Global scope vs Local scope
* Write and apply user defined functions.
* Apply functions to `vector` and `tibble` objects.
* Understand the programming concept of Loops.
* Utilise loops and understand their place in R.

***
