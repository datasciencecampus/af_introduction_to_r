---
title: "Intro to R- Chapter Four"
output:
  html_document: 
    theme: united
    highlight: tango
    toc: yes
    toc_float: yes
    number_sections: true
---

```{r, setup, include=FALSE}

# Working directory set to the Intro to R Refresh document so file paths can just
# be "Data/file.csv" etc
# n.b doesn't affect file paths for ![] imgs

knitr::opts_knit$set(root.dir = '..')
```

<hr style="width:100%;height:4px;border-width:0;color:gray;background-color:#dd4814; opacity:1"> 
```{r, echo=FALSE}
htmltools::img(src = knitr::image_uri("images/AF_DSC_banner.png"),
               alt = 'Learning Academy, Analysis Function and Data Science Campus Logos', 
               style="vertical-align:middle")

```
<hr style="width:100%;height:4px;border-width:0;color:gray;background-color:#dd4814; opacity:1"> 

<!--- Date course last updated and a contact for any help needed. --->
<center> Course Updated: October 2021 | <a href="mailto:Data.Science.Campus.Faculty@ons.gov.uk?subject=Help with course Intro to R">Need help? Contact the team.</a></center>
<br>

***
# Working with Data frames{-}

***

# Learning Objectives

<br>

**The goals of this chapter are to:**


* Understand the importance of clean variable names.

* Be able to clean column names using `janitor`or `gsub`.

* Be able to sort data.

* Be able to `select` data.

* Be able to `filter` data.

* Be able to use the `mutate` function and use the pipe operator.

* Be able to join data.

***

<br>

# Exercise {.tabset .tabset-fade}




## **Exercise**{-}


1. Before we begin, could you load the packages below,

   - `tidyverse`

   - `janitor`



2. Read in the file **`titanic.csv`** and assign it to `titanic`

***

<br>

## **Hint**{-}



The code below demonstrates how you can load a package.

```{r eval = FALSE}
# loading a package

library(package_name)
```


The code below demonstrates how you can read csv data.

```{r, eval = FALSE}
# Importing csv data

dataframe_name <- readr::read_csv(file_path)
```

***

<br>

## **Show Answer**{-}

```{r echo = TRUE, message = FALSE, warning = FALSE}
# Load packages

library(tidyverse)
library(janitor)


# Importing CSV data using readr package and read_csv function
# Specifying missing values by adding a vector, 
# na = c() of what should be 
# classed as missing values

titanic <- readr::read_csv("Data/titanic.csv", 
                           na = c("*", ".", "", "NULL"))

# To display the data
titanic
```
# {-}

As a reminder our columns are:

* **Pclass**: Passenger’s class, 1 = 1st (Upper), 2 = 2nd(Middle), 3 = 3rd(Lower)
* **Survived**: Survived (1) or died (0), 0 = No, 1 = Yes
* **Name**: Passenger’s name
* **Sex**: Passenger’s sex
* **Age of Passenger**: Passenger’s age
* **SibSp**: Number of siblings/spouses aboard
* **Parch**: Number of parents/children aboard
* **Ticket**: Ticket number
* **Fare**: Fare
* **Cabin**: Cabin number
* **Embarked**: Port of embarkation, C = Cherbourg, Q = Queenstown, S = Southampton


We can see more details on the [Data Dictionary](https://www.kaggle.com/c/titanic/data)

***

<br>

# Column Names

In the previous section we looked at reading data into R and also inspecting it. 

In this section we are going to look at how to manipulate it.

In the previous session we stated that every column in a data frame is a variable and it is good practice to not have spaces within variable names, as spaces makes it harder for us to call on the variables when we need to use them.

When you enter data in Excel, you most often don’t think too much about what you call each column. After all, you just label them once and as long as they are meaningful to you, what does it matter if the column name is a long combination of CAPITALLETTERS, lowercaseletters, and numbers?

When you are working with variables in R though, you need to type the name of each variable, every time you want to work with it. So, it makes sense to make your column names as simple, but meaningful as possible.

>**Ideally, they should also be consistently formatted.**

***


For example if we wanted to pick the `name of Passenger` column from the titanic dataset. 


>**The code below will not work!** 


```{r, eval = FALSE}

# Selecting data using the $ symbol
# note this WILL NOT WORK because of the blank spaces

titanic$name Of Passenger
```


To get around this we enclose `name of passenger` with back ticks like the code below - this is the key above the tab key on the left hand side of your keyboard.


```{r, eval = FALSE}

# Selecting data using the $ symbol
# note this now works because of the back ticks

titanic$`name Of Passenger`

```


If your column names have spaces and you don't get rid of them, you must use backticks.


However its good practise to remove spaces and symbols.


We can see the column names by using the  `names()` function to access the `name` attribute of the data.

```{r}
# Getting the column names using the names function

names(titanic)
```

As we can see our column names have spaces and some start with capital letters and some with small letters, we can clean the names using the either the `janitor package` or `gsub`.

***


## Cleaning Column Names {.tabset .tabset-fade}


### **janitor Package**{-}

The `janitor` package offers many functions used to manipulate data, for example removing empty rows and columns, finding duplicates within a data frame. In this session we will use the library to to clean our data set names.

We can clean the names of our dataset with the **janitor::`clean_names()`** function as shown below.

We are overwriting the original titanic data frame with a version with the column names cleaned.

```{r}

# Cleaning the column names using the janitor
# package and the clean_names() function.
# This will put all names in lower case letters and 
# replace blank spaces with underscores.

titanic <- janitor::clean_names(titanic)

# Getting the column names of the dataset

names(titanic)
```


`clean_names()` removes spaces, symbols, changes characters to lower case and makes all columns start with letters.


This is the default setting, other options we could use are:

```{r, eval = F}

# other options on the cases we can specify
# within the clean_names function

"snake", "lower_camel", "upper_camel", 

"screaming_snake", "lower_upper", "upper_lower", 

"all_caps", "small_camel", "big_camel", "mixed"

```


Which can be put inside the `clean_names()` function as shown below:


```{r, eval = F}
# Specifying the case within the clean_names function

janitor::clean_names(titanic, case = "snake")
```

***

<br>

 
### **gsub**{-}

We can also do this using the function **`gsub()`**. 

Here this is used on the column names, but it can also be used on the contents of text columns too.


The code below replaces any instance of the characters within the first set of quotes, with the contents of the second set of quotes.

For example, the output of `gsub(" ", "_", "piece of text")` would be `piece_of_text`.



```{r, eval = F}
# We can apply different substitution to the names of our columns.

# Using gsub to replace a blank space with an underscore

names(titanic) <- gsub( pattern = " ",  # what to look for
                        replacement = "_", # what to replace it with
                        x = names(titanic)) # where to look
```

<br>

The `tolower()` function changes a string of characters to lower case.


```{r, eval = F}
# We can lower case the names of the data frame.

names(titanic) <- tolower(names(titanic)) 
```

## {-}

We can also rename column names. 

The first argument is the data frame to be changed, the second is the column and what it will be changed to.



```{r}
# Renaming a column using the package dplyr
# using the rename() function
# here we are renaming age_of_passenger with age

titanic_renamed <- dplyr::rename(titanic, age = age_of_passenger)

# To Display the Data

titanic_renamed

```

<br>

We can also use the `tolower()` on full columns as example below. 
Here I am selecting the name_of_passenger column.
 
```{r}
# Selecting the name of passenger column using the $ symbol
# Using the tolower function 
# This lower cases all records in the column we have chosen.

titanic_renamed$name_of_passenger <- tolower(titanic$name_of_passenger) 


```

***

<br>

# dplyr


This is one of the most powerful tools in the *tidyverse*, which makes data manipulation simple and code easy to read.

We are going to look at the following concepts,

1. arrange/sort
2. select
3. filter
4. mutate
5. joining data


`dplyr` functions (verbs) all have the same structure.


```{r, eval = F}
# This is the format they follow.

verb(data, more information)
```

***

<br>

![Image showing an example of Cheat Sheet](../Images/data-transformation-cheat-sheet.png) \

***

<br>


## Arrange

Our data is displayed in the same order as the source data.

We may want to sort our data, based on specific columns, to do this we use the function **`arrange()`**.


>**`arrange()` lets you sort data by a variable.**

We can sort the column `fare` into ascending order with the code below.


```{r}
# We input the data we want to sort, 
# and what column we are going to sort it by.

titanic_sorted <- dplyr::arrange(.data = titanic,
                                  fare)

```

<br>

Lets look at the `fare` column before sorting the data.

```{r echo=FALSE, message=FALSE, warning=FALSE}
library(kableExtra)

titanic %>% 
  kable() %>% 
  kable_styling(bootstrap_options = c("striped", "hover", "condensed")) %>% 
  scroll_box(width = "100", height = "700px")
```


<br>

<br>

Lets now look at the `fare` column after sorting it. If we don't specify how we are sorting, the default is to sort in *ascending* order.


```{r echo=FALSE, message=FALSE, warning=FALSE}
titanic_sorted %>% 
  kable() %>% 
  kable_styling(bootstrap_options = c("striped", "hover", "condensed")) %>% 
  scroll_box(width = "100", height = "700px")
```

<br>

<br>

`.data` is the argument name for the data argument in `dplyr`.


It is optional, but can help us read the code more effectively.


To sort in descending order, we use the code below:

We input the data we want to sort, and how we are going to sort it, by specifying **`desc()`**.

```{r}
# We input the data we want to sort, 
# and what we are going to sort it by.

titanic_sorted <- dplyr::arrange(.data = titanic,
                                  desc(fare))
```

<br>

```{r echo=FALSE, message=FALSE, warning=FALSE}
titanic_sorted %>% 
  kable() %>% 
  kable_styling(bootstrap_options = c("striped", "hover", "condensed")) %>% 
  scroll_box(width = "100", height = "700px")
```

## Exercise{.tabset .tabset-fade}


### **Exercise**{-}

**If you haven't cleaned your column names using janitor as in the previous section, do that now!**

1. Can you sort the titanic data set by age *and* fare.

2. Can you sort the titanic data set by age *and* fare in *descending* order for both variables.

***

<br>

### **Hint**{-}


1. Can you sort the titanic data set by age *and* fare.





```{r, eval = FALSE}
# Sort the titanic data based on two variables.

titanic_sorted <- dplyr::arrange(.data = dataset,
                                  first_variable,
                                  second_variable)
```

2. Can you sort the titanic data set by age *and* fare in descending order for both variables.

   To sort both descending order we have to use the **`desc()`** function.

***

<br>


### **Show Answer**{-}

1. Can you sort the titanic data set by age *and* fare.



```{r}
# Sort the titanic data based on two variables.

titanic_sorted <- dplyr::arrange(.data = titanic,
                                  age_of_passenger,
                                  fare)
```

When sorting by multiple variables, R will sort the data by the first column specified - `age` - first and then will sort by `fare`.

<br>

```{r echo = FALSE, message = FALSE, warning = FALSE}

# To display just part of the dataset

library(kableExtra)

library(dplyr)

titanic_sorted %>%
  select(age_of_passenger, fare, everything()) %>% 
  kable() %>% 
  kable_styling(bootstrap_options = c("striped", "hover", "condensed")) %>% 
  scroll_box(width = "100", height = "500px")
```

<br>

2. Can you sort the titanic data set by age *and* fare in descending order for both variables.

   To sort both descending order we have to use **`desc()`** around each column name.

   If you only had one `desc` on the `age_of_passenger`, it will show `age_of_passenger` in          descending order, but fare in ascending.


```{r}

# Sorting both variables in descending order.
# You have to specify desc for both variables

titanic_sorted <- dplyr::arrange(.data = titanic,
                                  desc(age_of_passenger),
                                  desc(fare))
```


<br>


```{r echo = FALSE, message = FALSE, warning = FALSE}

# To display just part of the dataset

library(kableExtra)

library(dplyr)

titanic_sorted %>%
  select(age_of_passenger, fare, everything()) %>% 
  kable() %>% 
  kable_styling(bootstrap_options = c("striped", "hover", "condensed")) %>% 
  scroll_box(width = "100", height = "500px")
```

<br>

***

<br>


## Select

Sometimes we will want to work with smaller “cut down” Data Frames that contain fewer columns.

**`select()`** allows us to pick entire columns from our data.


Previously we selected columns using the `$` symbol and the indexing operator `[]`.


We will opt to use `dplyr` functions which allow us to keep our code efficient and readable even with complex queries.


The **`dplyr::select()`** function, in its simplest form, takes two arguments. 

The first, like all `tidyverse` functions, being the tibble we are interested in, and the second being the column name.

To select a few columns just add their names in the select statement. 

The order in which you add them, will determine the order in which they appear in the output.


```{r}
# Selecting data

titanic_one_variable <- dplyr::select(.data = titanic, 
                                      name_of_passenger)
# To display the data

titanic_one_variable
```

<br>

This has returned the `name_of_passenger` column from `titanic` in the form of a tibble. 

If we want to select multiple columns, we have to first collect the column names together using a character vector, and then pass that as our second parameters. 

```{r}
# Selecting data

titanic_three_variables <- dplyr::select(.data = titanic,
                                         name_of_passenger, 
                                         age_of_passenger,
                                         pclass)

# To display the data

titanic_three_variables
```

<br>

We can select columns which are next to each other in chunk as below.

To select a chunk of columns use the,start_col:end_col syntax:

```{r}
# Selecting data
# We can select multiple variables which are next to each other
# By using the : the code below will select all columns between
# pclass and age_of_passenger

titanic_five_variables <- dplyr::select(.data = titanic,
                                         pclass:age_of_passenger)

# To display the data

titanic_five_variables



```


<br>

The real power of the `select()` function comes from its flexibility.


For example, suppose we wanted to select all columns excluding `name`, `age` and `pclass`. We could tediously type all the columns names we need, or instead:


```{r}
# Selecting data
# We can use the `-` to exclude sets of columns

titanic_minus_three_variables <- dplyr::select(.data = titanic, 
                                               -name_of_passenger, 
                                               -age_of_passenger, 
                                               -pclass)

# To display the data

titanic_minus_three_variables

# we can also place the columns names in vector as below
# we only need one minus symbol

titanic_minus_three_variables <- dplyr::select(.data = titanic, 
                                               -c(name_of_passenger, 
                                                  age_of_passenger, 
                                                  pclass))
```

<br>

```{r, echo = FALSE, message = FALSE, warning = FALSE,eval=FALSE}

titanic_minus_three_variables %>%
  kable() %>% 
  kable_styling(bootstrap_options = c("striped", "hover", "condensed")) %>% 
  scroll_box(width = "100", height = "300px")
```


We can use the `-` to exclude sets of columns.

<br>

We can also select the columns using numbers, positive or negative, to drop.


For example the code below will select the first 4 columns and then column 7.


```{r}
# We can both use regular sequences with ":" 
# and specific numbers.

titanic_number_select <- dplyr::select(.data = titanic, 
                                       1:4, 7)

# To display the data

titanic_number_select
```


<br>


```{r, echo = FALSE, message = FALSE, warning = FALSE, eval=FALSE}

titanic_number_select %>%
  kable() %>% 
  kable_styling(bootstrap_options = c("striped", "hover", "condensed")) %>% 
  scroll_box(width = "100", height = "300px")
```

<br>

In this example we select all columns, except column 2.


```{r}
# The negative indicates which columns we do not want.

titanic_number_select <- dplyr::select(.data = titanic, 
                                       -2)

# To display the data

titanic_number_select
```

<br>

```{r, echo = FALSE, message = FALSE, warning = FALSE, eval=FALSE}

titanic_number_select %>%
  kable() %>% 
  kable_styling(bootstrap_options = c("striped", "hover", "condensed")) %>% 
  scroll_box(width = "100", height = "300px")
```

<br>

This flexibility is further enhanced by the `select helper` functions. These are functions which allow you select columns based on their names.


* `starts_with(match)`: Starts with a prefix.
* `ends_with(match)`: Ends with a suffix.
* `contains(match)`: Contains a literal string.
* `matches(match)`: Matches a [regular expression](https://www.regular-expressions.info/quickstart.html).
* `everything()`: Selects all variables.
* `last_col()` gives the last column 


<br>

These functions are passed after the first parameter. e.g.

```{r}
# Selecting columns

titanic_starts_with <- dplyr::select(.data = titanic, 
                                     starts_with("s"))

# To Display the data

titanic_starts_with
```

```{r, echo = FALSE, message = FALSE, warning = FALSE, eval=FALSE}

titanic_starts_with %>%
  kable() %>% 
  kable_styling(bootstrap_options = c("striped", "hover", "condensed")) %>% 
  scroll_box(height = "300px")
```

<br>


It is important to note, all `tidyverse` functions work on and return a copy of the altered data. More often than not, the returned object is another `tibble`, even if it's a single column. 


<br>

## Exercise{.tabset .tabset-fade}



### **Exercise**{-}


1. Can you select from the titanic data set, the second, third and fourth columns?


2. Can you select the columns, `pclass`, `survived`, `name_of_passenger`, `sex_of_passenger`, `age_of_passenger` and `embarked`?


3. Can you select just the last column?


4. Can you select the columns that end in the word "passenger"?


5. Can you reorder the columns so that, `name_of_passenger`, `age_of_passenger` are the first 2 columns? **Hint: You can use the relocate function**

***

<br>



### **Hint**{-}

1. Can you select from the titanic data set, the second, third and fourth columns?

   Selecting the second, third and fourth column.

   Remember we can select by position or by name.


```{r, eval = FALSE}

# Selecting data
# You will need to specify the columns 


titanic_select_exercise <- dplyr::select(.data = titanic, 
                                                  column_name,
                                                  column_name)
```

2. Can you select the columns, `pclass`, `survived`, `name_of_passenger`, `sex_of_passenger`, `age_of_passenger` and `embarked`?


```{r, eval = F}
# Selecting data
# You will need to specify the columns 


titanic_select_exercise <- dplyr::select(.data = titanic, 
                                                 column_name:column_name, embarked)
```

3. Can you select just the last column?

   Remember we can select by position or by name. HINT: `embarked` is the last column.


4. Can you select the columns that end in the word "passenger"?

   You might want to use something that helps you select the words of the columns, by what those     columns `ends_with()`.


5. Can you reorder the columns so that, `name_of_passenger`, `age_of_passenger` are the first 2 columns? **Hint: You can use the relocate function**


***

<br>

### **Show Answer**{-}


1. Can you select from the titanic data set, the second, third and fourth columns?

   Selecting the second, third and fourth column.

```{r}
# Selecting data

titanic_select_exercise <- dplyr::select(.data = titanic, 
                                          2:4)

# Alternative

titanic_select_exercise <-  dplyr::select(.data = titanic, 
                                          survived, 
                                          name_of_passenger,
                                          sex_of_passenger)

# To display the data

titanic_select_exercise

names(titanic_select_exercise)
```



<br>

2. Can you select the columns, `pclass`, `survived`, `name_of_passenger`, `sex_of_passenger`, `age_of_passenger` and `embarked`?

  Selecting the columns, pclass, survived, name_of_passenger, sex_of_passenger, age_of_passenger    and embarked.

```{r}
# Selecting data

titanic_select_exercise <- dplyr::select(.data = titanic, 
                                          1:5, embarked)

# Alternative

titanic_select_exercise <- dplyr::select(.data = titanic, 
                                          1:5, last_col()
                                         )

# To display the data

titanic_select_exercise

names(titanic_select_exercise)
```

<br>

3. Can you select just the last column?

```{r}
# Selecting data

titanic_select_exercise <- dplyr::select(.data = titanic,
                                         last_col()) 

#To display the data
titanic_select_exercise

names(titanic_select_exercise)

```

<br>

4. Can you select the columns that end in the word "passenger"?

   You could also type the column names.

```{r}

# Selecting data

titanic_select_exercise <- dplyr::select(.data = titanic,
                                         ends_with("passenger")) 


#To display the data

titanic_select_exercise

names(titanic_select_exercise)
```


<br>


5. Can you reorder the columns so that, `name_of_passenger`, `age_of_passenger` are the first 2 columns? **Hint: You can use the relocate function**

You will see that is lots of different ways to do this, you can use the function `relocate()`

```{r}
# Relocating data

titanic_select_exercise <- dplyr::relocate(.data = titanic,
                                           name_of_passenger,
                                           age_of_passenger)

# To display the data

titanic_select_exercise 

```


You can also use the `select()` function, here we just have add the helper function `everything()` which selects the rest of the columns.


```{r}

# Selecting data

titanic_select_exercise <- dplyr::select(.data = titanic,
                                         name_of_passenger,
                                         age_of_passenger, 
                                         everything()
                                         )


#To display the data

titanic_select_exercise

names(titanic_select_exercise)
```

<br>

For more advanced ways to select columns refer to this excellent blog [Data Wrangling Part 1: Basic to Advanced Ways to Select Columns](https://suzan.rbind.io/2018/01/dplyr-tutorial-1/)


***

<br>

## Filter

**`filter()`** allows us to pick specific entries (rows) which satisfy a given logical condition.


A conditional statement returns `TRUE` if the condition is met. 

To create a logical condition, we have to use the logical operators.

<br>


Logical Operator| Description
:--------------:|:------------:
        <       | Less Than
       <=       | Less Than or Equal To
       \>       | Greater Than
       >=       | Greater Than or Equal To
    ==          | Equal To
       !=       | Not Equal To
       \|       | Or
        &       | And
        !       | Not
      any()     | Checks if any value in a logical vector are TRUE
      all()     | Checks if all values in a logical vector are TRUE
      is.na()   | Is NA?
      between() | Is between 2 numbers

      
<br>


      
>**Note: The `!` allows us to flip or invert an expression. Basically, if an expression returns `[TRUE, TRUE, FALSE]`, the same expression with a `!` in front of it will return `[FALSE, FALSE, TRUE]`.**


>**Note: `==` is used to test equality and `=` is used to define values to pass into functions.**

***

<br>


### Single Conditional Filtering


We can filter out a new data set where `pclass` is equal to 2.

This is referred to as single conditional filtering as we only have one condition.


```{r}
# Select passengers (rows) who were in class (pclass) 2.

secondclass <- dplyr::filter(.data = titanic, 
                             pclass == 2)

#To display the data

secondclass
```


<br>

>**A quick way to check that the filter worked is to look at all the unique values, in the data set above, using the `unique()` function.**


Note here am using the `$` to select the column pclass.


```{r}
# Returns the set of unique values in the data set.
# finding out how many unique values 
# are in the titanic dataset pclass column

unique(titanic$pclass)


# finding out how many unique values 
# are in the secondclass dataset pclass column

unique(secondclass$pclass)
```

We can see that on the original dataset the titanic, we have three(1,2,3) different unique values in the pclass column and in our new filtered dataset we have one unique value (2).


Another example, we can filter out the passengers who paid more than 200.


```{r}
# Select passengers who paid more than 200

fare_more_than_200 <-  dplyr::filter(.data = titanic, 
                                     fare > 200)


# finding out how many unique values 
# are in the faremorethan200 dataset fare column

unique(fare_more_than_200$fare)

```

<br> 

```{r echo = FALSE, message = FALSE, warning = FALSE}

# To display just part of the dataset

library(kableExtra)

library(dplyr)

fare_more_than_200 %>%
  kable() %>% 
  kable_styling(bootstrap_options = c("striped", "hover", "condensed")) %>% 
  scroll_box(width = "100", height = "500px")
```

<br>

### Exercise{.tabset .tabset-fade}


#### **Exercise**{-}

1. Use filter to show the row for the passenger named: 'Birkeland, Mr. Hans Martin Monsen'


2. How many passengers in the dataset are male?


3. How many passengers are under 18 years of age?


<br>



##### **Extension Exercise**{-}


4. What proportion of passenger in the dataset survived?

***

<br>


#### **Hint**{-}


1. Use filter to show the row for the passenger named: 'Birkeland, Mr. Hans Martin Monsen'

  Remember R is case sensitive and character data needs to have speech marks.


```{r, eval = FALSE}
# filtering the dataset by name_of_passenger

titanic_filter_exercise <- dplyr::filter(data, 
                                          condition)

# To display the data

titanic_filter_exercise
```


2. How many passengers in the dataset are male?

   First filter the data.

   Then find out the number of rows using **`nrow()`**.


```{r, eval = F}
# showing the number of rows in our new filtered dataset

nrow(titanic_filter_exercise)
```


3. How many passengers are under 18 years of age?

   First filter the data.

   Then find out the number of rows using **`nrow()`**.

<br>



##### **Extension Exercise**{-}


4. What proportion of passenger in the dataset survived?

   First filter the data - passengers which survived are those with a `1` in  the `survived`         column.

   Then find out the number of rows using **`nrow()`**.

   Then calculate the percentage using the formula **nrow(filtered data)/nrow(full data)*100**.

```{r, eval = FALSE}

# calculating the percentage, by dividing the total number 
# of rows in new filtered dataset by the total number 
# of rows in fulldataset then multiplied by 100

percentage_of_passengers_survived <- nrow(titanic_filter_exercise)
                                     /nrow(titanic)*100

# To display the data

percentage_of_passengers_survived
```

***

<br>

#### **Show Answer**{-}


1. Use filter to show the row for the passenger named: 'Birkeland, Mr. Hans Martin Monsen'


```{r}
# filtering the dataset by name_of_passenger

titanic_filter_exercise <- dplyr::filter(.data = titanic, 
                                         name_of_passenger 
                                         == 'Birkeland, Mr. Hans Martin Monsen')

# To display the data

titanic_filter_exercise
```
Or as an alternative you could use the `str_detect` function from the `stringr` package.

```{r}
titanic_using_str_detect<- dplyr::filter(.data = titanic,
                                stringr::str_detect(name_of_passenger,'Hans'))
```
<br>

2. How many passengers in the dataset are male?


```{r}
# filtering the dataset by sex_of_passenger

titanic_filter_exercise <- dplyr::filter(.data = titanic, 
                                         sex_of_passenger
                                         == 'male')

# To display the data

titanic_filter_exercise

# showing the number of rows in our new filtered dataset

nrow(titanic_filter_exercise)
```

<br>

3. How many passengers are under 18 years of age?


```{r}
# filtering the dataset by age_of_passenger

titanic_filter_exercise <- dplyr::filter(.data = titanic, 
                                        age_of_passenger
                                        < 18)

# To display the data

titanic_filter_exercise

# showing the number of rows in our new filtered dataset
nrow(titanic_filter_exercise)
```

<br>



##### **Extension Exercise**{-}

4. What proportion of passenger in the dataset survived?


```{r}
# filtering the dataset by survived
titanic_filter_exercise <- dplyr::filter(.data = titanic, 
                                          survived == 1)


#To display the data
titanic_filter_exercise


# showing the number of rows in our new filtered dataset
nrow(titanic_filter_exercise)

# calculating the percentage, by dividing the total 
# number of rows in new filtered dataset by the total 
# number of rows in fulldataset then multiplied by 100
percentage_of_passengers_survived <- nrow(titanic_filter_exercise)/nrow(titanic)*100

# To display the data
percentage_of_passengers_survived
```

<br>


### Multiple Conditional Filtering 


So far, we've only filtered according to individual conditions set on a single column, but there is no reason we can't use multiple conditions to filter by several conditions and/or columns at once. However, we do need to think about how the conditions relate to each other, as we have two options to establish these relationships.

* **and** relationships are given by the **&** symbol. This implies both/all conditions must be met for a row to evaluate to `TRUE`.
* **or** relationships are given by the **|** symbol. This implies that if _any_ of the conditions can be met a given row evaluates to `TRUE`.

You can think of **`between()`** as being special version of multiple condition filters. **`between()`** is an **and** condition - greater than (or equal to) the lower bound **and** less than (or equal to) the upper bound.

R also implements a multiple 'or' condition in the form `%in%`, where any rows that have a value occurring in a given vector will be included in the output tibble.

<br>

| Condition 1 | Condition 2  | & (AND) Equates to |  &#124; (OR) Equates to |
|:-----------:|:------------:|:------------------:|:------------------:|
|     True    |     True     |        True        |        True        |
|     True    |     False    |        False       |        True        |
|    False    |     True     |        False       |        True        |
|    False    |     False    |        False       |        False       | 


<br>



Let's look at some examples:
```{r}
# Select passengers who were in class 1 AND female

titanic_filter_example <- dplyr::filter(.data = titanic, 
                                        pclass == 1 
                                        & sex_of_passenger == "female")

```

```{r, echo = FALSE, message = FALSE, warning = FALSE}

titanic_filter_example %>%
  kable() %>% 
  kable_styling(bootstrap_options = c("striped", "hover", "condensed")) %>% 
  scroll_box(width = "100", height = "300px")
```
<br>

```{r}
# Select passengers who were female OR children (under 18)

titanic_filter_example <- dplyr::filter(.data = titanic, 
                                        sex_of_passenger == "female" 
                                        | age_of_passenger < 18)

```

```{r, echo = FALSE, message = FALSE, warning = FALSE}

titanic_filter_example %>%
  kable() %>% 
  kable_styling(bootstrap_options = c("striped", "hover", "condensed")) %>% 
  scroll_box(width = "100", height = "300px")
```

<br>

```{r}
# Select passengers who paid more than 100 
# but less than 250 for their fare.

titanic_filter_example <- dplyr::filter(.data = titanic, 
                                        between(fare, left = 100, right = 250))
```


<br>

```{r, echo = FALSE, message = FALSE, warning = FALSE}

titanic_filter_example %>%
  kable() %>% 
  kable_styling(bootstrap_options = c("striped", "hover", "condensed")) %>% 
  scroll_box(width = "100", height = "300px")
```

<br>

```{r}
# Select passengers who embarked 
# in Southampton or Cherbourg.


titanic_filter_example <- dplyr::filter(.data = titanic,
                                        embarked == "C" | embarked == "S" )

# If you are filtering more than one value
# You can use the %in% which is
# A more compact method of looking 
# for a set of specific values.

titanic_filter_example <- dplyr::filter(.data = titanic,
                                        embarked %in% c('S','C'))

# Alternatively if is easier to  not  select  
# an item, here we are not  selecting  "Q"
# which leaves us with "S" and  "C"

titanic_filter_example <- dplyr::filter(.data = titanic,
                                          embarked != "Q")
```

<br>

```{r, echo = FALSE, message = FALSE, warning = FALSE}

titanic_filter_example %>%
  kable() %>% 
  kable_styling(bootstrap_options = c("striped", "hover", "condensed")) %>% 
  scroll_box(width = "100", height = "300px")
```

<br>

### Exercise{.tabset .tabset-fade}


#### **Exercise**{-}

1. Select passengers who are in classes 2 or 3, what percentage of passengers is this?

2. How many passengers were travelling alone?


<br>


##### **Extension Exercise**{-}

3. What proportion of passengers who 'embarked' in Cherbourg ('C') or Queenstown ('Q') survived? 

***

<br>

#### **Hint**{-}

1. Select passengers who are in classes 2 or 3, what percentage of passengers is this?

   The & (Shift and 7) symbol indicates an AND relationship.

```{r, eval = FALSE}
# filtering the dataset on multiple conditions

titanic_filter_exercise <- dplyr::filter(data,
                                         condition)

# calculating the percentage, by dividing 
# the total number of rows in new filtered dataset 
# by the total number of rows in fulldataset 
# then multiplied by 100

nrow(titanic_filter_exercise) / nrow(titanic) * 100 
```

2. How many passengers How many passengers were travelling alone? i.e do not have siblings or spouses ('sibsp'), and parents or children ('parch') on the boat?

   The & (Shift and 7) symbol indicates an AND relationship, and should be used to filter off the    two columns listed - both values should be zero.

<br>


##### **Extension Exercise**{-}


3. What proportion of passengers who 'embarked' in Cherbourg ('C') or Queenstown ('Q') survived? 

   We need to find the passengers who embarked in those two cities, and then the amount of them      that survived. 

```{r, eval = FALSE}

nrow(survived) / nrow(embarked_cherbourg_and_queenstown)
```

***

<br>

#### **Show Answer**{-}

1. Select passengers who are in classes 2 or 3, what percentage of passengers is this?

```{r}
# filtering the dataset on multiple conditions
# The | indicates one condition or the other must be TRUE.

titanic_filter_exercise <- dplyr::filter(.data = titanic, 
                                         pclass == 2 | pclass == 3)

#To display the data

titanic_filter_exercise

# calculating the percentage, by dividing the total 
# number of rows in new filtered dataset 
# by the total number of rows in fulldataset then multiplied by 100

nrow(titanic_filter_exercise) / nrow(titanic) * 100 
```


<br>

2. How many passengers How many passengers were travelling alone? i.e do not have siblings or spouses ('sibsp'), and parents or children ('parch') on the boat?


```{r}
# filtering the dataset on multiple conditions

titanic_filter_exercise <- dplyr::filter(.data = titanic,
                                         sibsp == 0 & parch == 0)

# showing the number of rows in the filtered dataset

nrow(titanic_filter_exercise)
```

<br>

```{r, echo = FALSE, message = FALSE, warning = FALSE}

titanic_filter_exercise %>%
  kable() %>% 
  kable_styling(bootstrap_options = c("striped", "hover", "condensed")) %>% 
  scroll_box(width = "100", height = "300px")
```

<br>


##### **Extension Exercise**{-}

3. What proportion of passengers who 'embarked' in Cherbourg ('C') or Queenstown ('Q') survived? 

```{r}
# filtering the dataset on multiple conditions to find the embarked passengers

embarked_cherbourg_and_queenstown <- dplyr::filter(.data = titanic,
                                                   embarked == 'C' | embarked == 'Q')

# filtering the dataset a single condition to find the survivors

survived <- dplyr::filter(embarked_cherbourg_and_queenstown, 
                          survived == 1)

# showing the number of rows in the filtered dataset

nrow(survived) / nrow(embarked_cherbourg_and_queenstown) * 100

```

<br>

```{r, echo = FALSE, message = FALSE, warning = FALSE}

survived %>%
  kable() %>% 
  kable_styling(bootstrap_options = c("striped", "hover", "condensed")) %>% 
  scroll_box(width = "100", height = "300px")
```



<br>

For more advanced ways to filter columns refer to this excellent blog [Data Wrangling Part 1: Basic to Advanced Ways to Select Columns](https://suzan.rbind.io/2018/02/dplyr-tutorial-3/), this covers the functions, `filter_all()`, `filter_if()` and `filter_at`.


***

<br>

## Generating New Variables

To create a new variable, or a new column, in our `tibble` we will use the **`dplyr::mutate()`** function.

Code to create a new column follows the pattern below, where we state the name of the new column and the use the = to state what we want to be in that column.

```{r, eval = F}
# generating new variables

data_frame_name <- dplyr::mutate(data_frame,
                                 name_of_new_column = contents of new column)
```


<br>


### Constant Value Variables

The simplest example would be adding a constant value to each row in our `tibble`. 

```{r}
# generating new variables

mutate_example <- dplyr::mutate(.data = titanic, 
                                string_twos = "two")

```
```{r, echo = FALSE, message = FALSE, warning = FALSE}

mutate_example %>%
  kable() %>% 
  kable_styling(bootstrap_options = c("striped", "hover", "condensed")) %>% 
  scroll_box(width = "100", height = "300px")
```


<br>

### Creating Variables Based on Existing Columns

We can perform mathematical operations and even functions on existing columns in the **`mutate()`** function using column names.

Let's look at some examples:

We can capitalise the sex column.

```{r}
# Capitalise sex column
# Here we are over writing the  sex_of_passenger column
# If you give your new column the same name  as  an existing column 
# It will overwrite it.

mutate_example <- dplyr::mutate(.data = titanic,
                                sex_of_passenger = stringr::str_to_upper(sex_of_passenger))

```
```{r, echo = FALSE, message = FALSE, warning = FALSE}

mutate_example %>%
  kable() %>% 
  kable_styling(bootstrap_options = c("striped", "hover", "condensed")) %>% 
  scroll_box(width = "100", height = "300px")
```
<br>

Another example is creating the family size of the person.

This is the number of siblings or spouses on board (sibsp), the number of parents or children on board (parch), plus 1 (the person themselves).

```{r}
# Determining family size on board

mutate_example <- dplyr::mutate(.data = titanic,
                                family_size = parch + sibsp + 1)
```
```{r, echo = FALSE, message = FALSE, warning = FALSE}

mutate_example %>%
  kable() %>% 
  kable_styling(bootstrap_options = c("striped", "hover", "condensed")) %>% 
  scroll_box(width = "100", height = "300px")
```


<br>

As well as mathematical operators and functions we can use conditionals. 
```{r}
# Creating a logical column which is TRUE 
# if passenger is female, false otherwise.

mutate_example <- dplyr::mutate(.data = titanic,
                                is_female = (sex_of_passenger == "female"))


```
```{r, echo = FALSE, message = FALSE, warning = FALSE}

mutate_example %>%
  kable() %>% 
  kable_styling(bootstrap_options = c("striped", "hover", "condensed")) %>% 
  scroll_box(width = "100", height = "300px")
```

<br>

The key note from this being, with **`mutate()`**, we can do almost anything to every row in our data frame. 

There are some functions which work with **`mutate()`** and enable us to perform more complicated tasks. **`recode()`** lets us map one value to another throughout the entire column e.g.:

```{r, eval = FALSE}
# Recoding variables
# Note Recode does not have a .data argument

dplyr::recode(titanic$survived, 
              '1' = TRUE, 
              '0' = FALSE)
```

To do this in the context of an entire `tibble` we have to use **`recode()`** with **`mutate()`**.
```{r}
# Generating new variables

recode_example <- dplyr::mutate(.data = titanic,
                                survived_logical = recode(survived, '1' = TRUE, '0' = FALSE))
```

<br>

```{r, echo = FALSE, message = FALSE, warning = FALSE}

recode_example %>%
  kable() %>% 
  kable_styling(bootstrap_options = c("striped", "hover", "condensed")) %>% 
  scroll_box(width = "100", height = "300px")
```


<br>

### Exercise{.tabset .tabset-fade}



#### **Exercise**{-}

1. Create a new column, called `fare_dollars`, in this column we should have the fare converted to dollars, the exchange rate is £1 to $1.39.

2. Round the `fare-dollars` column


***

<br>

#### **Hint**{-}

1. Create a new column, called `fare_dollars`, in this column we should have the fare converted to dollars, the exchange rate is £1 to $1.39.

```{r, eval = FALSE}
# Generating new variables

fare_dollars <- dplyr::mutate(data,
                              new column name = content of new column)
```

2. Round the `fare_dollars` column

```{r, eval=FALSE}
# Generating new variables

round_fare <- dplyr::mutate(data,
                            new column name = content of new column)
```


***

<br>

#### **Show Answer**{-}

1. Create a new column, called `fare_dollars`, in this column we should have the fare converted to dollars, the exchange rate is £1 to $1.39.

```{r}
# Generating new variables

fare_dollars <- dplyr::mutate(.data = titanic,
                              fare_dollars = fare * 1.39)
```

```{r, echo = FALSE, message = FALSE, warning = FALSE}

fare_dollars %>%
  kable() %>% 
  kable_styling(bootstrap_options = c("striped", "hover", "condensed")) %>% 
  scroll_box(width = "100", height = "300px")
```

<br>

2. Round the `fare_dollars` column.

```{r}
# Generating new variables

round_fare <- dplyr::mutate(.data = titanic,
                            fare_dollars = round( fare * 1.39))
```
```{r, echo = FALSE, message = FALSE, warning = FALSE}

round_fare %>%
  kable() %>% 
  kable_styling(bootstrap_options = c("striped", "hover", "condensed")) %>% 
  scroll_box(width = "100", height = "300px")
```

<br>

For more advanced ways to mutate columns refer to this excellent blog [Data Wrangling Part 1: Basic to Advanced Ways to Mutate Columns](https://suzan.rbind.io/2018/02/dplyr-tutorial-2/), this covers the functions, `mutate_all()`, `mutate_if()` and `mutate_at`.


***

<br>

### Deleting data

We can also use the **`mutate()`** function to delete data.

We can add a new column called `child` to our titanic data set.

We can quickly see the names of our data set using the the **`names()`** function.

```{r}
# Generating new variables

titanic_mutate_exercise <- dplyr::mutate(.data = titanic,
                                         child = age_of_passenger < 18)
# To display the column names

names(titanic_mutate_exercise)
```
We can delete the column using the code below.

We take the titanic data set and set equal the column we want to delete to `NULL`.

```{r}
# Setting a column = NULL effectively removes it.

titanic_mutate_exercise <- dplyr::mutate(.data = titanic_mutate_exercise, 
                                         child = NULL)

# finding out the names of the columns in the dataset

names(titanic_mutate_exercise)
```

Alternatively, this will work too.

```{r, eval = F}

# selecting a column using the $ sign and assigning 
# it to NULL

titanic_mutate_exercise$child <- NULL
```

<br>

***

<br>

## The Pipe Operator **`%>%`**


The Pipe Operator **`%>%`** makes it possible to chain a sequence of functions. 

In R code **`%>%`** can be read as "AND THEN". It takes the output of one action "AND THEN" uses that as the input of the next action. Where an action could be calling a variable, a function or anything else that returns some information. 

The short cut for this operator is CTL + SHIFT + M

Up until now if we wanted to perform a sequence of actions on data, we'd have do something along the lines of:

```{r}

# Filtering the titanic dataset  
   
first_class_survivors <- dplyr::filter(.data = titanic,
                                        pclass == 1 & survived == 1)

# Selecting only the columns needed 
# Note here I am using first_class_survivors as my dataset
  
selected_first_class_survivors <- dplyr::select(.data = first_class_survivors,
                                                 name_of_passenger, 
                                                 age_of_passenger, 
                                                 embarked, 
                                                 fare)

# Sorting the data
# Note here I am using selected_class_survivors as my dataset
   
sorted_first_class_survivors <- dplyr::arrange(.data = selected_first_class_survivors,
                                                desc(age_of_passenger))  

```

Or alternatively this very nested sequence!


```{r}
# This may be very hard to read and understand - the pipe will make this much more readable!

sorted_first_class_survivors <- dplyr::arrange(.data = 
                                                 dplyr::select(.data = 
                                                                 dplyr::filter(.data = titanic,
                                                                  pclass == 1 & survived == 1),
                                                               name_of_passenger,
                                                               age_of_passenger,
                                                               embarked,
                                                               fare)
                                               , desc(age_of_passenger))

```
<br>

```{r, echo = FALSE, message = FALSE, warning = FALSE}

sorted_first_class_survivors %>%
  kable() %>% 
  kable_styling(bootstrap_options = c("striped", "hover", "condensed")) %>% 
  scroll_box(width = "100", height = "300px")
```

<br>


With the pipe operator, this simplifies to:

```{r}
# Chaining dplyr commands

sorted_first_class_survivors <- titanic %>%
                                dplyr::filter(pclass == 1 & survived == 1) %>% 
                                dplyr::select(name_of_passenger, 
                                              age_of_passenger,
                                              embarked, 
                                              fare) %>% 
                                dplyr::arrange(desc(age_of_passenger)) 
```


```{r, echo = FALSE, message = FALSE, warning = FALSE}

sorted_first_class_survivors %>%
  kable() %>% 
  kable_styling(bootstrap_options = c("striped", "hover", "condensed")) %>% 
  scroll_box(width = "100", height = "300px")
```

<br>

>**Notice how the `select()`, `arrange()` and `filter()` functions don't use the .data argument as it is being piped in from the previous command!**


As you can see the pipe operator helps us:

* Structure the sequence of our data operations from left to right, as opposed to from inside to out.
* Avoid nested function calls and make code more "readable".
* Reduce the need for local variables.
* Make it easy to add steps anywhere in the sequence of operations.


The pipe operator functionality comes from the `magrittr` package. Its implementation is designed for `tidyverse`, but it also works in some cases outside the `tidyverse`.


The pipe function is one of the most powerful features of the `tidyverse`. In fact, having a standardised chain of processing actions is called "a pipeline". Making pipelines for data manipulation is great, because you can apply that pipeline to any incoming data with a given formatting and have your output in a friendly format.

<br>

### Exercise{.tabset .tabset-fade}

#### **Exercise**{-}

Lets practice piping a few `dplyr` functions.


1. Can you find the names of the 8 oldest passengers who embarked in Southampton?

***

<br>

#### **Hint**{-}

1. Can you find the names of the 8 oldest passengers who embarked in Southampton?

```{r, eval = FALSE}

# Chaining dplyr commands using the %>%

southampton_oldest_passengers <- titanic %>%
                          dplyr::filter() %>% # where they got on the boat
                          dplyr::select() %>% # keep only columns we need
                          dplyr::arrange() %>% # sort the data
                          head(n = 8) # This will only show the top 8


#To display the data

southampton_oldest_passengers
```

***

<br>



#### **Show Answer**{-}

1. Can you find the names of the 8 oldest passengers who embarked in Southampton?

```{r}
# Chaining dplyr commands using the %>%

southampton_oldest_passengers <- titanic %>%
                          dplyr::filter(embarked == "S") %>%
                          dplyr::select(name_of_passenger, age_of_passenger) %>%
                          dplyr::arrange(desc(age_of_passenger)) %>% 
                          head(n = 8)


#To display the data

southampton_oldest_passengers
```


***

<br>

## Joining Data

Often all the data you need to answer a question are not contained within a single dataset, but across several. Datasets can be joined, or 'merged', to allow data to be analysed together, but only **if the two datasets share a common reference or identifier.**

Linking data come in a number of forms and are commonly referred to as 'indexical' data. Some examples include:

* Your NHS number, allowing data linkage across the NHS for primary, secondary, tertiary care episodes and prescribing.
* Any account number (e.g. banking, utilities, travel card, council tax etc.) can acts as a point of linkage between different sets of data.
* Your email, phone number, social media handles etc.
* Your address can also act as a spatial reference, linking you to your neighbourhood, local services etc

***

<br>

### Types of Joins

In R we use a group of `join` functions. These are prefixed by the type of join we choose to implement.

Once you have established that two `tibbles` share a reference that will permit a join to be conducted, you will see:

* `inner_join` - Only rows with reference values that appear in both `tibbles` are merged.
* `full_join` - All data from the left and right `tibble` is retained, matched up where possible.
* `left_join` - All data from the 'left' `tibble` is retained, and any matching rows are merged from the 'right' `tibble`.
* `right_join` - All data from the right and anything that matches from the left. Effectively, the reverse of 'Left'.


This can be easier to understand graphically:

<br>

<br>


![](../Images/sql-joins.png)

<br>

Lets look at some examples

We will use the 2 datasets, which come as part of the `dplyr` package. These data sets describe band members of the Beatles and Rolling Stones. 

```{r}
# To display the data

band_members
```

You will need to assign it to see it within the environment window as shown below,

```{r}
# Assigning the data

band_members <- dplyr::band_members
```


```{r}
# To display the data

band_instruments
```

Lets assign this one as well. Note that `dplyr` has two slightly different datasets (band_instruments and band_instruments2 - which we will use later on). 

```{r}
# Assigning the data

band_instruments <- dplyr::band_instruments
```


These data sets have one common column which is `name`, so we can join them based on this.

We can see that **John** and **Paul** appear in both datasets while **Mick** is appears only in the band member and **Keith** in band instruments.

I’m going to say that `band_members` is my “left” data frame, and that `band_instruments` is my “right” data frame.

Let’s look at how we do an **inner join** in code. We’re going to use the function **`inner_join()`**.


```{r}
# The left data frame is given by the argument x
# The right frame is given by the argument y
# We need to include the column we would like to join with

band_membership_inner_join <- dplyr::inner_join(x = band_members, 
                                                y = band_instruments,
                                                by = "name")
# To display the data

band_membership_inner_join
```

We can see that the inner join returned only the 2 members that appear in both datasets.


If you don't specify which column to join by, `R` will look to match by any column that matches.


We can also use the `pipe operator`, as shown below.

```{r}
# Joining data using the pipe operator
# Here the left dataset is specified first
# Then we can chain our join to it

band_membership_inner_join <- band_members %>% 
                              dplyr::inner_join(band_instruments, 
                                                by = "name")

# To display the data

band_membership_inner_join
```
 
 <br>
 
Now let try a **full join**.

```{r}
# full join

band_membership_full_join <- band_members %>% 
                             dplyr::full_join(band_instruments,
                                              by = "name")

# To display the data

band_membership_full_join
```

We can see that the full join returned all 4 members with some missing values for those that don't appear in both datasets.

<br>

Now lets try a **left join**.

```{r}
# left join

band_membership_left_join <- band_members %>% 
                             dplyr::left_join(band_instruments, 
                                              by = "name")

# To display the data

band_membership_left_join
```

We can see that the left join returns only those that appear or both datasets or left dataset, which is why Keith is missing here.

<br>

A **right join** is just the opposite of the left join.

```{r}
# Right join

band_membership_right_join <- band_members %>% 
                              dplyr::right_join(band_instruments, 
                                                by = "name")

# To display the data

band_membership_right_join
```

We can see that the right join returns only those that appear or both datasets or right dataset, which is why Mick is missing here.


<br>

If we're joining on more than one column we can specify using the parameter `by = c(vector))`.

This is shown below.

```{r, eval = F}

# Joining using multiple columns

join_left <- dplyr::left_join(x = first_dataset, 
                              y = second_dataset,
                              by = c("column name", "column name"))


```

<br>

### Exercise {.tabset .tabset-fade}

#### **Exercise**{-}

1. Run the code below, can you figure out why its not working. **HINT:Remember what we need to be able to join 2 datasets.**

We will be using band_instruments2 from the `dplyr` package for this exercise, rather than band_instruments as previously. 

```{r, eval=F}
# Load the data

band_members <- dplyr::band_members

band_instruments2 <- dplyr::band_instruments2

# Full join

band_membership_full_join <- band_members %>% 
                              dplyr::full_join(band_instruments2)

# To display the data

band_membership_full_join
```
<br>


##### **Extension Exercise**{-}

2. Using `band_members` and `band_instruments2` perform a "full" join.

   * Join on *BOTH* the column containing `name` and the column containing `artist`.
  
   * Note that the names of these columns may not be the same in both data frames.

   * Use the help function to explore solutions to this. **HINT: look at the example section**

***

<br>
   

#### **Show Answer**{-}


1. Run the code below, can you figure out why its not working. **HINT:Remember what we need to be able to join 2 datasets.**

We will be using two datasets from the `dplyr` package for this exercise. 

```{r, eval=F}
# Load the data
  # Note later code will run without this step, it has been included to demonstrate that datasets from packages are available 

band_members <- dplyr::band_members

band_instruments2 <- dplyr::band_instruments2

# Full join

band_membership_exercise <- band_members %>% 
                              dplyr::full_join(band_instruments2)

# To display the data

band_membership_exercise
```

The code above will give the error message below;

**Error: `by` must be supplied when `x` and `y` have no common variables. i use by = character()` to perform a cross-join. Run `rlang::last_error()` to see where the error occurred.**

This is because the datasets do not have any columns with the same name, band_members has name while band_instruments2 has artist.

```{r}
# To display the data

band_members
```

```{r}
# To display the data

band_instruments2
```


<br>


##### **Extension Exercise**{-}

2. Using `band_members` and `band_instruments2` perform a "full" join.

   * Join on *BOTH* the column containing `name` and the column containing `artist`.
  
   * Note that the names of these columns may not be the same in both data frames.

   * Use the help function to explore solutions to this. **HINT: look at the example section**
   
```{r}
# Full join
# We can join with different column names

band_membership_exercise <- band_members %>% 
                              dplyr::full_join(band_instruments2,
                                               by = c("name" = "artist"))

# To display the data

band_membership_exercise
```




***

<br>

### bind_rows()

Another common way in which datasets are combined is by binding them. Unlike the join function, the binding functions do not try to match by a variable, but instead simply combine datasets by appending one set of data to the bottom of the other. If the datasets don’t match by the appropriate dimensions, one obtains an error.

This is where we can add data on to the bottom of an existing data frame, If you have two (or more) data frames that share the same data structure.

You can use the `bind_rows()` function.





```{r}
# Creating vectors

name <- c("Paul","Katherine", "Almas", "Pragya")

band <- c("Beatles","Beatles", "Stones", "Stones")

# Creating a tibble

new_band_members <- tibble::tibble(name, band)
```

For example, looking at the 2 data frames below;

```{r}
# To display the data

band_members

# To display the data

new_band_members

```

<br>

We can use the **`bind_rows()`** function, which will simply merge two data frames into one by appending the rows.

```{r}
# Combining 2 dataframes using bind_rows() function

binded_rows_data <- band_members %>% 
                    dplyr::bind_rows(new_band_members)

# To display the data

binded_rows_data

```

<br>

We can see our new additions - Paul, Katherine, Almas and Pragya here now.

Here we’re assigning the output to a new Data Frame – `binded_rows_data.

<br>

### Union()

Another function useful function is  **`union()`** which will merge the data from both data frames but keep only the distinct (unique) rows. That means, any duplicated rows that exist in the target data frames are not going to be brought over to the current data frame

```{r}
# Combining 2 dataframes using union() function

union_data <- band_members %>% 
              dplyr::union(new_band_members)

# To display the data

union_data

```
We can see that Paul was duplicated and is not included when we use union instead.

<br>

<hr style="width:100%;height:4px;border-width:0;color:gray;background-color:#dd4814; opacity:1"> 


# Summary - Working with Data frames{-}

* You should now be able to import data into R

* Understand the importance of clean column names

* Manipulate data frames to extract information from them by:
    + Selecting columns,
    + Filtering rows,
    + Generating new variables,
    + Sorting Data
    + Joining Data



<hr style="width:100%;height:4px;border-width:0;color:gray;background-color:#dd4814; opacity:1">

<br>

# Next Chapter{-}

***

**In the next chapter we will look at Summary Statistics and Aggregation.**

***