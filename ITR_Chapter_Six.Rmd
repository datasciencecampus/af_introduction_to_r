---
title: "Intro to R - Session Six"
output:
  html_document: 
    theme: united
    highlight: tango
    toc: yes
    toc_float: yes
    number_sections: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
```{r, echo=FALSE}
htmltools::img(src = knitr::image_uri("./Images/LATree.PNG"),
               alt = "logo", 
               style = "position:absolute; top:0; right:0; padding:10px; width:200px;")
```


# Session Six

## Learning Objectives

**The goals of this session are to:**

* Be able to use conditional statements: *if*, *else* and *else if*.

* Be able to use loops: *for* loops and *while* loops

* Learn what functions are.

* Understand why we need to use functions.

* Be able to write functions.

* Have a basic understanding of scoping within functions.


## Conditional Statements

A conditional statement will check whether a condition is TRUE or FALSE.

So, if our statement meets this criteria apply this action, otherwise do nothing.

This is useful if we want a function to run only when our data meets certain conditions, this is termed `control flow`.

We use comparison and logical operators.

### Comparison Operators

| Operator | Description | 
| ------ |:------| 
|   ==   | equal to | 
|  !=    | not equal to |   
| <      | less than|
| >      | greater than |
| <=     | less than or eaqual to|
| >=     | greater than or equal to|

### Logical Operators

| Operator| Description| 
| ------  |:------:| 
|   &     | And | 
|   \|    | Or |
|    !    | Not|


You might want an action to be perfomed depending on the outcome, to be able to do this in R, we use the;

- *if* statement

- *else* statement

- *else if* statement

### IF statement

They follow the basic structure below,


```{r, eval=FALSE}

if (logical condition) { 
  
  commands
  
}

```

- So, `if` followed by round brackets, in which we enter our logical condition 

- then curly brackets in which we enter a series of commands. It"s good practice to put the commands on a new line as it is easier to read. Notice the code is also indented so we can see that it is part of the *if* statement.

*if* statements on their own do not work with vectorised arguments. They will only work with a single element and not a vector of elements. If applied to a vector it will only check the first element. If this does not meet the condtion then no statements will be executed, you will get an error/warning.

#### **Example**

We can look at the example below, lets say we set our `height` as 6.

Our condition is `height is equal to 6`

Our command is if `height is equal to 6` to `print "me also!"`

```{r}

height <- 6

if (height == 6) { 
  
  print("me also!")
  
}

```
### ELSE Statement

It has to be used together with an `if statement`.

The `else` statement does not require a condition; the code of an `else` statement gets executed whenever the result of an `if` statement is `FALSE`.

They follow the basic structure below,

```{r, eval=FALSE}

if (logical condition) { 
  
  commands
  
} else {
  
  other commands
}

```

All we have added is `else` and an additional commands.
`else` has to be on the same line as the closing bracket or else it will not work.

#### **Example**

Going back to our previous example in which we said `height <- 6`.

We can add an `else` statement.

This will get executed if the `height` is *not* equal to 6.

So lets say `height` is now equal to 7.

The first condition is `FALSE` (`height == 6`), hence it executes the `else` statement.


```{r}

height <- 7

if (height == 6) { 
  
  print("me also!")
  
} else {
  
  print("Not my height")
  
}

```
### ELSE IF

This allows you to further customise your control flow. With `else if`, you can add as many conditions as we want.

The else if statement specifies a new condition if the first condition is `FALSE`.

Keep in mind that R ignores the remainder of the control structure once a condition has been found that is `TRUE` and the corresponding expressions have been executed.

They follow the basic structure below,

Itâ€™s important that the `else if` keyword comes on the same line as the closing bracket of the previous part of the control structure.

```{r, eval=FALSE}

if (logical condition) { 
  
  Commands - executed if logical condition is true
  
} else if (second condition) { 
  
  Commands - executed if the logical condition is false and second condtion is true
  
} else if (third condition) { 
  
  Commands - executed if logical condition and second condition are false
  
} else {
  
  Commands - executed when all conditions are false
  
}

```

#### **Example**
```{r}

height <- 9

if (height == 6) { 
  
  print("me also! my height is 6")
  
} else if (height == 7) { 
  
  print("me also! my height is 7")
 
} else if (height == 8) { 
  
  print("me also! my height is 8")
  
} else {
  
  print("Not my height")
  
}

```

#### **Exercise**{.tabset .tabset-fade}

##### **Question**

Now lets try and practise.

can you write an `else if` statement, that looks at `grade`

It should class grades 

- between 0 and 40 as failed.

- between 41 and 50 a D

- between 51 and 60 as C

- between 61 and 70 as B

- between 71 and 100 as an A

It should also print the grade and an optional comment on the grade.

##### **Show Answer**

```{r}
grade <- c(56)

if (grade <= 40 & grade >=0) { 
  
  print("You have absolutely failed!")
  
  print("We are really sorry for you")
  
} else if (grade <= 50 & grade >=41) { 
  
  print("You have got a D")
  
  print("Need to work harder")
  
} else if (grade <= 60 & grade >=51) { 
  
  print("You have got a C")
  
  print("Not bad, can do better")
  
} else if (grade <= 70 & grade >=61) { 
  
  print("You have got a B")
  
  print("Well done")
  
} else if (grade >= 71 & grade <=100) { 
  
  print("You have got an A")
  
  print("Congratulations, this is excellent")
  
} else {
  
  print("Error, grades can not be less than 0 or more than 100")
  
}


```


## Loops

A loop is a way to repeat a sequence of instructions under certain conditions. 

They allow you to automate parts of your code that are in need of repetition.

In R you have multiple options when repeating operations, `vectorised operations`, `for loops`, and `apply functions`.

We covered "vectorised operations" in Session 2 (section 1.4), we will look at loops in this session and we will not cover the apply functions in this course.

### Types of loops
 
 We are going to look at two types of loops.

- `for` loops

- `while` loops



#### `for` loops {.tabset .tabset-fade}

These are the most common types.

An interable is an object that can be iterated through, one element at a time. Lists and vectors are both iterables.

They follow the basic structure below,

```{r, eval=FALSE}

for (Variable in Vector) { 
  
  commands
  
}


```
 
- So we start with the word `for`

- followed by `()` brackets where we specify an index variable, `i` is commonly used but it can be anything that you want.

- then the word `in`

- then specify an interable. In this case it is `Vector`.

- followed by the `{}` curly brackets, which will have our commands, these could be multiple lines of code.

lets look at an example.

We start by creating a vector, I have created one with **even numbers from 2 to 10**.


```{r}

example_vector <- c(2, 4, 6, 8, 10)

```

We will now run our `for` loop on our vector.

```{r}


for (i in example_vector) { 
  
  print(i + 1)
  
}

```

So our index variable is `i`, our iterable is `example_vector` and then our command is to add `1`.

So the first time the loop runs **(Iteration)** the index variable `i` was assigned to our first number in our vector `2` and since our command is add a 1, we get a result of 3.

An **iteration** is a single run through lines of code contained in a loop.

So the second time the loop runs the index variable `i` is assigned to the second number in our vector `4` and this adds a `1`, we get a result of `5`.

This will continue until the command has been run into all elements of the vector.

We cant really use our output like this as it just prints to the console, if we wanted to save our output into something we wanted to use. We could assign it.

```{r, eval=FALSE}

for (i in example_vector) { 
  
  odd_numbers <- append(odd_numbers, i + 1)
  
}

odd_numbers

```

The code above will not work as odd_numbers does not exist outside the brackets **We will look at this under function scoping below**, to solve this issue we create an empty vector, called `odd_numbers` and we add our results into the vector using the `append` function.

**append() function simply adds elements to a vector.**.

```{r}

odd_numbers <- c()

for (i in example_vector) { 
  
  odd_numbers <- append(odd_numbers, i + 1)
  
}

odd_numbers

```


#### While loops{.tabset .tabset-fade}

The main difference between the `while` loops and the for loops is that we dont specify the number of iterations in the loop.

We want the loop to keep running until a specified condition is met.

They follow the basic structure below,

```{r, eval=FALSE}

while (logical condition) { 
  
  commands
  
}


```
- So, stat with the word `while`

- followed by the `()` brackets in which we specify our logical condition, using the **conditional operators**.

- and then `{}`, which surrounds our commands. These commands will be run repeatedly in order as long as the specified condtion is `TRUE`.

lets look at an example:

- If we say `x` is equal to 2.

- and we set out condtion to be `x < 6`

- then print `x`

- and then `add a 1`

```{r}

x <- 2

while (x < 6) { 
  
  print(x)
  
  x <- x + 1
}


```

- The starting value is `2`. (As set by `x <- 2`).

- The first thing the loop does it to test it against the condition `x < 6`.

- in our case `x` is `2` which is less than `6`, so the condtition is `TRUE`.

- We can move on to the next part of the loop, which is `print(x)`, where `x` is equal to `2`. (This is our first 2 in the output)

- The next step is to override the value of `x` by adding a `1`. (`x <- x + 1`)

- As our new `x` value is still less than `6`, the condition is `TRUE`, so it will print `x` which is now `3` and get a new value for `x` (`x <- x + 1`), which will now be `4`.

- This continues until we get to `x` is `5`, this passes the fist conditional statement `x < 6` so it will print a `5` but after we add the `1`, (`x <- x + 1`) and `x` becomes `6`, it is not less than `6`, so it fails the first conditional statement and the loop cannot continue, hence our results are between `2-5`.


**The order of the commands is important.**

##### **Question**

- Can you work out what the ouput would be if we reversed the order of the commands?. i.e, start with `y <- y + 1` and then `print(x)`

- What would happen if we removed the line of code `y <- y + 1`

```{r, eval=FALSE}

y <- 2

while (y < 6) { 
  
  y <- y + 1
  
  print(y)
  
}


```


##### **Show Answer**

```{r}

y <- 2

while (y < 6) { 
  
  y <- y + 1
  
  print(y)
  
}


```
- As we can see we now get values between `3` and `5`.

- So we start we with `y` is equal to `2`, which passes the first condition `y < 6`.

- We then add a `1` to it `y <- y + 1`, so `2 + 1`. Which is equal to `3`.

- Our fist output is `3`.

- And that continues on.

- For the next question, if we removed the code `y <- y + 1`, `y` would always be less than `6` and the program would be stuck in an infinite loop, as R will keep running the code. You will have to hit the stop sign to exit the loop.


#### Exercise loops{.tabset .tabset-fade}


##### **Question**

Code a `while` loop with the following characteristics:

- Assign the value of a variable `temperature` to be 40.

- The condition of the `while` loop, should check if the temperature is higher than `20`

- The first command in the body should print out `"Its way too hot!"`

- The next command should decrease the `temperature` by `2` and assign this new value to `temperature` again.

##### **Show Answer**

```{r}
temperature <- 40

# Code the while loop
while (temperature > 20) {
  
  print("It way too hot!")
  
  temperature <- temperature - 2
  
}

# Print out the temperature variable
temperature

```

##### **Question**

We can combile a `loop` and and `if else statements`.

- Create a vector, with values from `1-7` and assign it to `number_of_takeaways_ordered`.

- Create a `for` loop with an `if` and `else` statement shows that if you order more than `2` takeaways a week it will print `"too many"` and if you order less than two it prints `"enough"`.

##### **Show Answer**

```{r}

number_of_takeaways_ordered <- c(1, 2, 3, 4, 5, 6, 7)

for (i in number_of_takeaways_ordered) { 
  
  if (i > 3) { 
    
    print("too many")
    
  } else { 
    
  print("enough")
    
  }
  
  print(i)
  
}

```
##### **Question**

Can you write an loop with a `if` and `else` statement, that prints out numbers from `1` to `30`.

But for multiples of `3` print `Fizz` instead of the number

For multiples of `5` print `Buzz`

And for multiples of both `3` and `5`, print `FizzBuzz`

##### **Show Answer**

```{r, eval=FALSE}

for (i in 1:30) { 
  
  if (i %% 3 == 0 & i %% 5 == 0) {
    
    print("FizzBuzz")
  }
  else if (i %% 3 == 0) {
    
    print("Fizz")
  }
  else if (i %% 5 == 0) { 
    
    print("Buzz")
  }
  else {
    
    print(i)
  }
  
}

```

The first thing we do is we assign the element within the sequence.

```{r}

for (i in 1:30) { 
  
  print(i)
  
}

```

We then need to find the multiples of `3`, we will use the `%%` modulo operator, which returns the remainder of a division.

If a number is a multiple of another number it will return a `0`.

The code below, will apply the modulo to the numbers between `1` and `30` by `3` and if the remainder is `0`, it will print `Fizz` and if not print the number.

```{r}

for (i in 1:30) { 
  
  if (i %% 3 == 0) { 
    
    print ("Fizz")
  
  } else {
      
      print(i)
  }
  
}

```

Simmilary for the multiples of `5`, the code below will divide the numbers between `1` and `30` by `5` and if the remainder is `0`, it will print `Buzz` and if not, the number.

```{r}

for (i in 1:30) { 
  
  if (i %% 5 == 0) { 
    
    print ("Buzz")
  
  } else {
      
    print(i)
  }
}

```

Now for the `FizzBuzz` 

We need to have the `if` statement to check if `i` is multiple of `3` and `5` before it checks them individually.

If it is a multiple of `3` and `5`, the loop will reset and go to the next value in the range.

If not it will try `5` and then `3`.

If none are multiples of `i` it will print `i` and go on to the next value in the range until the end.

```{r}

for (i in 1:30) { 
  
  if (i %% 3 == 0 & i %% 5 == 0) {
    
    print("FizzBuzz")
  }
  else if (i %% 3 == 0) {
    
    print("Fizz")
  }
  else if (i %% 5 == 0) {
    
    print("Buzz")
  }
  else {
    
    print(i)
  }
  
}

```

## FUNCTIONS

We have previously used ready-made functions (from Base R or from packages) In R already, e.g `excel_sheets()`, `help()`,`merge()`,`clean_names()`, `mean()`, we are now going to look at creating our own functions, which we call **user defined functions**.

We can see that basically a function takes an **input**, perfoms some **commands** and produces an **output**.

### Why we use functions

- They make code shorter and easier to understand.

- They make it easier to update code, as we only need to change one place.

- Functions alow us to easily repeat commands.

- They help reduce errors caused from copied and pasted code.

### Basic Structure of a function

Basic structure of a function looks like below,

```{r, eval=FALSE}

function_name <- function(input) { 
  
  statements of what the function is doing
  
  return(the function output)
  
}


```
So, it will have a;

- `Function name`

- `Parameters/Arguments/Inputs` 

- `Function body`

- `Output of the function`


### Function Name

Always good practice for the function name to be what the function going to do, it should be short but clear.

It can be any valid variable name. This is assigned by the assignment operator. For R to know the variable is a function you need to use word `function` as above.

### Inputs/Parameters/Arguments

These are the inputs of a function, they are set in the `()` brackets, sometimes referred to as `arguments` or `parameters`.

These can be any R object, data frames, numbers or others, separated by commas.

The statements in the body are indented by two spaces, which makes the code easier to read but does not affect how the code operates.

**Arguments are optional; that is, a function may contain no arguments, we will look at an example.** 

**Some arguments have default values specified, we will look at an example of this.**


### Function body

These are statements of what you want a function to do, they are set in the curly brackets. This can be long or short, its ideal for a function to do only one thing.
 
Variables created within the function body do not exist outside it, and therefore cannot be accessed.

### Examples{.tabset .tabset-fade}

#### **Function with no Arguments**

```{r}

#Creating a function

sayHello <-  function() { 
  
  print("Hello there !")
  
}


#Calling a function

sayHello()

```

Once we run our function, it gets created in the environment window ready for us to use, in order to use it, termed **calling a function**

we simply type it.

As this function has no inputs, we don"t need to specify anything within the brackets.

#### **Function with a default value**

If you remember from the previous session where we talked about getting summary statistics, where we calculated the`standard deviation`, using the `school` dataset from the `total_number_of_pupils`.

We used the `sd()` function, in which our input was the `total_number_of_pupils`, we had another input which was `na.rm = TRUE`. (removed missing values from the calculation.)

```{r, eval=FALSE}


sd(school$total_number_of_pupils, na.rm = TRUE)


```

If we look at the `sd()` function in detail.

```{r, eval=F}

?sd

```


![](Images/sd.PNG)

We can see that in the usage, it states that,

```{r, eval=F}

sd(x, na.rm = FALSE)

```

The function has 2 arguments, `x` and `na.rm = FALSE`.

- The `x` needs to be defined by us.

- But `na.rm = FALSE`, Already has a value specified. Not including this argument when using the function will not cause an error.

We can do this for our user defined functions too, using the basic structure below,

```{r, eval=FALSE}

function_name <- function(first_argument, second_argument = a_default_defined_value) { 
  
  statements of what the function is doing
  
  return(the function output)
  
}

```

Looking at our example below, 

- We have created our function `function_with_default_value`.

- Our arguments are `x` and `xlabel1 = "I am adding my X label here"`, which i have already predefined. So wherever I state `xlabel1` I will get `"I am adding my X label here"`

- I have added a print command for `x`

- And then a `hist` function which prints a histogram, on `x` and uses the default value, for the `xlab`

- I have then called the function on R"s default dataset `iris` using the `Sepal.Length` column.

```{r}

function_with_default_value <- function(x, xlabel1 = "I am adding my X label here") { 
  
    print(summary(x))
  
    hist(x, xlab = xlabel1)
   
}
  
function_with_default_value(iris$Sepal.Length)

```


#### **Pythagoras Function Example**

We are now going to write a function that uses Pythagoras" theorem in order to calculate the hypotenuse (longest side) of a right angle triangle given the two other sides. The equation is given as $$a^2 + b^2 = c^2$$ where $a$, $b$ are the two known sides and $c$ is the longest side. In order to find the value of $c$ we can rearange the formula to $$c = \sqrt{a^2 + b^2}$$

The function will input values of $a$ and $b$ and then return the value of $c$ below.


```{r, eval=F}

# Function to calculate the value of the hypotenuse
find_the_hypotenuse <- function(a_value, b_value) {
  
  # Calculate the values of a^2 + b^2
  squared_sum_of_values <- a_value^2 + b_value^2
  
  # Calculate the value of c using the square root function `sqrt()`
  c_value <- sqrt(squared_sum_of_values)
  
  # Return the output value of our function.
  return(c_value)
}


# Assign test values to make sure our function works

a_test <- 3
b_test <- 4

# This should give us a value of c = 5

find_the_hypotenuse(a_test, b_test)

```
### Exercise {.tabset .tabset-fade}

#### **Question**

If we remember the exercise we did using the loop which prints `Fizz`, `Buzz` and `FizzBuzz`.

We could alternatively write a function.

Can you write a function, that will take an numerical input, a vector of numbers from 1 to 30.

But for multiples of `3` print `Fizz` instead of the number.

For multiples of `5` print `Buzz`.

And for multiples of both `3` and `5`, print `FizzBuzz`.



#### **Show Answer**

```{r}

# Define the function
fizz_buzz <- function(sequence_of_numbers) { 
  # Loop over all the numbers in the sequence vector
  for(each_number in sequence_of_numbers) {
    # Multiple of 3 and 5 condition
    if (each_number %% 3 == 0 & each_number %% 5 == 0) {
      print("FizzBuzz")
      
    }
    # Multiple of 5 condition
    else if (each_number %% 5 == 0) {
      print("Fizz")
      
    }
    # Multiple of 3 condition
    else if (each_number %% 3 == 0) { 
      print("Buzz")
    }
    # Multiple of neither condition
    else {
      print(each_number)
    }
  # End the for loop
  }
# End the function
}

# Create a vector

vector_to_test_fizz_buzz <- 1:30

#Apply the function to our vector

fizz_buzz(vector_to_test_fizz_buzz)


```


### Function Scoping

Simmilar to the loops in the session above, where we said, the variable `odd_numbers` does not exist outside the function.

```{r}
for(i in example_vector) { 

  odd_numbers <- append(odd_numbers, i + 1)
  
}

odd_numbers

```

function scoping implies that variables defined inside the function do not exist outside it. Variables created inside the function are local to that function and NOT accesssible outside of the function.

When we write and run a function, R creates a new, temporary environment for the function.

The function environment is temporary and stops existing after the function is run. We cannot access anything withing the function that was not returned by it using the `return` command.

### Example

Lets look at an example.

If you run the code below, it will return an error stating that object z is not defined, even though we have defined within the function as `z <- 5`. If we wanted to access that value of `z` we would have to run the function and assign the output to a new variable.

```{r, eval=FALSE}

scope_example <- function() { 
  
  z <- 5
  
  return(z)
}

z

```

### Exercise {.tabset .tabset-fade}

#### **Question**

What would you expect the function below to return?


```{r, eval=FALSE}

#Creating function which adds 1 to x

add_one <- function(x) {
  
  x <- 1 + x
  
  x
}

#creating a vector

test_vector <- c(1, 2, 3)

#Calling the function on our vector

add_one(test_vector)

```

#### **Show Answer**

```{r}

#Creating function which adds 1 to x

add_one <- function(x) {
  
  x <- 1 + x
  
  x
}

#creating a vector

test_vector <- c(1,2,3)

#Calling the function on our vector

add_one(test_vector)

z <- add_one(test_vector)

```

We can see that our function returns the same values for the vector `test_vector` 

as `x` was defined inside the `add_one` function and therefore it is not accessible outside of that function

## SUMMARY

We have looked at lot in this session, You should now be:

* **Be able to use conditional statements; if, else and else if statements.**

* **Be able to use loops; for loops and while loops.**

* **Know what functions are.**

* **Understand why we need to use functions.**

* **Be able to write functions.**

* **Have a basic understanding of scoping within functions.**

