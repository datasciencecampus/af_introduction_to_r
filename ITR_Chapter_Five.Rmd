---
title: "Intro to R - Summary Statistics"
output:
  html_document: 
    theme: united
    highlight: tango
    toc: yes
    toc_float: yes
    number_sections: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
```{r, echo=FALSE}
htmltools::img(src = knitr::image_uri("./Images/LATree.PNG"),
               alt = 'logo', 
               style = 'position:absolute; top:0; right:0; padding:10px; width:200px;')
```

***

# Learning Objectives



```{r echo=TRUE, message=FALSE, warning=FALSE}
# Load libraries

library(readr)
library(janitor)
library(dplyr)


# Read in data


titanic <- readr::read_csv("D:/Git/Intro_to_R_Refresh/Data/titanic.csv", 
                           na=c("", " ", "NULL"))

titanic <- janitor::clean_names(titanic)


```






# Descriptive Statistics

There are really two broad types of data in our `tibble` at the moment that we want to look at - numerical data (i.e. ints and doubles) and text data (i.e. character strings).

In this section, we will explore some basic univariate descriptive statistics.

## Descriptive Statistics for Numerical Data
Let's start with the numerical data, because that's the easiest to work with. The `dplyr::summarise()` function allows us to create one or more scalar variables summarising the variables of an existing `tibble`.  

The useful functions that we can use with summarise:

* `mean()` - The average (arithmetic mean) data value in the given column.
* `median()` - The middle value of an ordered vector of values.
* `sd()` - The standard deviation (spread) of values in the given column.
* `quantile()` - Produces sample quantiles corresponding to the given proportions (between 0 and 1). 
* `min()` - The smallest value in the given column.
* `max()` - The maximum data value recorded.
* `n()` - Counts the number of entries (rows).
* `n_distinct()` - Counts the number of unique entries for a given variable.

There are plenty more we could use, but this, like the rest of the course, is intended to give you a taste of what's possible. 

Let's look at some examples:
```{r}
summarise(titanic, mean(fare))
```

This highlights an important point, any operation applied to a column containing one or more `NA` values produces `NA`. Most functions in R, for best practice reasons, propagate `NA` values, requiring us to set the common parameter `na.rm` to TRUE. This will omit any `NA` values in our calculation and produce a more meaningful result, albeit on a subset of observed data. The intention here is that R wants the analyst to know `NA` values are present in the data and deal with them directly. 

```{r}
summarise(titanic, mean(fare, na.rm = TRUE))
```

To assign this a meaningful column name, we'd pass a keyword argument in `summarise()`.
```{r}
summarise(titanic, mean_fare = mean(fare, na.rm = TRUE))
```
`summarise()` is effectively computing out statistics and wrapping the result in a `tibble`. If we didn't care about the `tibble` output we could simply compute using base R syntax:
```{r}
mean(titanic$fare, na.rm = TRUE)
```

Like we saw with `mutate()` and other functions, we can compute multiple statistics through `summarise()`.
```{r}
summarise(titanic, median_fare = median(fare, na.rm = TRUE),
          mean_fare = mean(fare, na.rm = TRUE), 
          sd_fare = sd(fare, na.rm = TRUE),
          median_age = median(age_of_passenger, na.rm = TRUE),
          mean_age = mean(age_of_passenger, na.rm = TRUE),
          sd_age = sd(age_of_passenger, na.rm = TRUE))
```

The structure of our output above is not ideal. We could restructure using `tidyr` functions: `gather()`, `separate()` and `spread()`. This is slightly advanced for what we have covered so far, but an examples have been added to the additional materials for those keen to know.

Functions which return more than one value won't work well with `summarise()`. Therefore, these functions have to be called on the data directly instead.
```{r}
quantile(titanic$fare, na.rm = TRUE)
```


## Describing Text (or Categorical) Data {.tabset .tabset-fade}

Simple statistics on qualitative data include:

* `dplyr::distinct()` - Which will list all the unique values in a given column. 
* `dplyr::n_distinct()` - Takes a vector and counts how many unique values there are.
* `dplyr::count()` - Displays the number of occurrences of each unique entry in a given column.


Descriptive statistics below are for qualitative data, they don't work very well if every value in a field is a different piece of text!

```{r}
count(titanic, name_of_passenger, sort = TRUE)
```
Compared to:
```{r}
count(titanic, embarked)
```

### **Exercise**

1. How old is the oldest passenger in the dataset?
2. How many men and women are in the dataset?
3. Create a new column called 'std_fare' which is the 'fare' minus the mean fare, divided by the standard deviation.
4. Calculate the number of children in second class.

### **Hint**

### **Show Answer**

1. How old is the oldest passenger in the dataset?

```{r}

oldest_passenger <- max(titanic$age_of_passenger, na.rm = TRUE)

```

2. How many men and women are in the dataset?

```{r}

number_of_men_and_women <- count(titanic, sex_of_passenger)

```

3. Create a new column called 'std_fare' which is the 'fare' minus the mean fare, divided by the standard deviation.

```{r}

standard_fare <- dplyr::mutate(titanic, std_fare = (fare - mean(fare, na.rm = TRUE))/sd(fare, na.rm = TRUE))

```

# Aggregation

Aggregation means grouping data together by a particular grouping variable and producing a summary of one or more columns for that grouping variable.

We'll use the `dplyr::group_by()` function. 

This function can be really useful, especially when your data are disaggregate - e.g. data about individual units of people or things. 

`group_by()` allows you to aggregate by a categorical variable and summarise numerical data into a new `tibble`.

`.group_by()` works on a principle known as 'split-summarise-combine':

* Split - a `tibble` is divided into a set of smaller `tibbles` based on the grouping variable.
* Summarise - an aggregation is applied to each of the groups to create a single row for each group in the original `tibble`.
* Combine - bring together the aggregated `tibble` rows into a final new `tibble`.

Let's walk through what that might look like for the `titanic` `tibble`:

* Firstly, we decide to **split** the data by the 'pclass'. This divides the `titanic` `tibble` into effectively three separate `tibbles`, one for first, one for second and one for third class.
* Secondly, we **summarise** the `tibble` using a chosen aggregation function. You can either produce an aggregate statistic for all columns, or you can select specific columns on which to do the aggregation. 
* Finally, we get a **combined** `tibble` that contains the new aggregate statistics.

Let's look at that in code:

```{r}
# Grouped tibble by pclass
by_class <- dplyr::group_by(titanic, pclass)
by_class
```

Now let's find out the mean fare paid by each class
```{r}
summarise(by_class, mean_fare = mean(fare, na.rm = TRUE))
```

Hopefully this all sounds fairly straightforward! `group_by()` is a powerful tool, particularly when you are working with any kind of hierarchical data where you might want to know something aggregate about the groups within the data, for instance:

* individuals nested in households.
* employees nested in firms.
* patients nested in primary or secondary care trusts.
* small area geographies (e.g. wards, output areas, postcodes etc.) nested in larger geographies (e.g. districts, counties etc.)
* countries nested in supra-national entities.

or, demographic, cultural and socio-economic classes:

* individuals by age, sex, ethnicity, religion etc.
* employees by grade or occupational social class.
* households by neighbourhood deprivation rank or decile.
* experimental subjects in intervention and control arms of a trial.

We can also aggregate according to more complicated groupings:

```{r}
# Group by pclass and embarked. Then find the average fare paid by each group.
by_class_embarked <- group_by(titanic, pclass, embarked)
summarise(by_class_embarked, mean_fare = mean(fare, na.rm = TRUE))
```


